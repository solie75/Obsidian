진행하기에 앞서 Script 라이브러리의 분리 과정에서 layer, level, event, object editor 에 관한 과정이 누락된 것을 발견하였기에 Engine 라이브러리의 Source/ Script 폴더에 CPlayScript class 를 새로 만들어 Script 라이브러리의 CPlayerScript class 의 기능을 복사하고 이를 활용한다. 추후 누락된 기초 설계과정을 완성하고 Script 분리를 적용하기로 하자.
따라서 기존에 Client.cpp 에서 AddComponent(CPlayerScript); 하던것을 CLevelMgr 에서 구현한다.

# Material 추가

지난 번 추가한 Texture 는 만들고자하는 오브젝트의 표면이라면 Material 은 그 표면의 재질이다.  [[Lights and Materials]]

Material의 속성들을 포함하는 구조체를 선언한다. 이는 앞으로 상수버퍼에 추가된다.
1. struct.h 에 tMaterialConst 구조체 선언
- 다음의 맴버를 갖는다.
	- int arrInt[4];
	- float arrFloat[4];
	- Vec2 arrV2[4];
	- Vec4 arrV4[4];
	- Matrix arrMat[4];
! 이때 tMaterialConst 구조체의 각 맴버 변수가 어떤 역할을 하는지 나중에 파악하고 변수명을 변경할 것

2. Engine Library/ Source/ 07.Resource 에 <span style="color: yellow">3. Material 추가 및 CMaterial class 생성</span>
- 맴버 변수 
	(Private)
	- Ptr<CGraphicsShader.> 형으로 변수 (m_pShader) 선언.
	- tmaterialConst 구조체로 변수 (m_MaterialConst) 선언.
	- Ptr<CTexture.> 형으로 배열 (m_arrTex[TEX_END]) 선언.
		- 이때 define.h 에 enum 으로 TEX_PARAM 선언 맴버는 TEX_0~ TEX_7, TEX_END 로 총 9개이다.
	- (일반적으로 3D 그래픽에서 Texture 는 Material 에 포함되어 사용된다. Material 은 물체의 렌더링에 필요한 정보를 포함하는 구조체 또는 클래스이고 Texture 는 Material 에 연결되어 Material 이 렌더링 되는 동안 사용된다.)
- 맴버 함수
	(public)
	- 생성자의 초기화 부분에서 부모클라스인 CResource 클라스의 생성자를 호출하여 Resource_Type 을 material 로 저장한다.
	- void SetTextureParam(TEXTURE_PARAM _Param, const Ptr<CTexture.>& _Texture)
		- m_arrTexture[_Param] 에 _Texture 를 저장한다.
	- UpdateResourceData();
		Texture update 부분
		- m_arrTexture 배열의 모든 요소에 대해 UpdateTextureData() 를 호출한다.
			- 기존의 <span style="color: yellow">UpdateTextureDate를 수정</span>하여 매개변수를 int _iRegisterNum, int _PipelineStage 두개를 받는다.
			- <span style="color: yellow">define.h 에서 enum 으로 PIPELINE_STEAGE 를 선언</span>하고 요소로 다음을 둔다. PS_VERTEX = 0x00,PS_HULL = 0x01,	PS_DOMAIN = 0x02,	PS_GEOMETRY = 0x04, PS_PIXEL = 0x08, PS_ALL = PS_VERTEX | PS_HULL | PS_DOMAIN | PS_GEOMETRY | PS_PIXEL
				- 이것으로 각 요소는 8비트 중 하나의 비트가 1이고 나머지는 0인 모양을 하게 된다.
			- PIPELINE_STAGE 의 요소와 _PipelineStage 에 대해 비트연산자 (&) 를 사용하는 if 문으로 _PipelineStage 인자와 PIPELINE_STAGE 의 모든 요소와 비교하게 하고 해당하는 항목의 ~SetShaderResource(_iRegisterNum, 1, m_ShaderResourceview) 를 호출한다.
		Constant update 부분
		- CConstBuffer* 로 변수 (pMaterialBuffer) 선언하고 GetConstBuffer(CB_TYPE::MATERIAL)를 호출하여 CDevice 의 맴버변수 m_ConstBuffer 배열의 Material 부분을 pMateiralBuffer 에 저장한다.
		- pMaterialBuffer 에 대해 SetConstBufferData(&m_MaterialConst) 를 호출하여 
		- pMaterialBuffer 에 대해 UpdateConstBufferData() 를 호출한다.
			- 이때 <span style="color: yellow">UpdateConstBufferData() 를 수정</span>하여 CONTEXT 에 대해 VSSetConstBuffers() 만 호출하던 것에서 Hull, Domain, Geometry, Pixel 에 대한 ~ SetConstBuffer() 또한 호출한다.
	- void SetScalarParam(SCARAL_PARAM _Param, void* _Src);
		- Material 이 가진 속성을 설정하는 역할을 한다. 따라서 tMatrialConst 구조체와 같은 형태의 <span style="color: yellow">enum class (SCARAL_PARAM) 를 define.h 에 선언</span>한다. tMaterialConst 구조체의 배열을 다 풀어서 맴버화 하기 때문에 <span style="color: orange">SCARAL_PARAM의 맴버는 20개</span>이다.
		- Switch case 구조를 활용하여 매개변수인 _Param 을 그에 맞는 형식을 찾아 m_MaterialConst의 맴버에 저장한다. 그 구조는 다음과 같다.
```c++
switch(_Param)
{
	case INT_0:
	case INT_1:
	case INT_2:
	case INT_3:
		m_MaterialConst.arrInt[_Param] = *((int*)_Src);
		break;
	case FLOAT_0:
	case FLOAT_1:
	case FLOAT_2:
	case FLOAT_3:
		m_MaterialConst.arrFloat[_Param - FLOAT_0] = *((float*)_Src); // arrFloat 에 들어갈 FLOAT_0 부터 FLOAT_3 까지의 enum 값이 4~8 이므로 _Param - FLOAT_0 을 해주어 arrFloat 에 들어가는 값을 0~3으로 쓰임에 맞게 인덱스를 맞춰준다.
		break;
	...
}
```
이러한 구조로 m_MaterialConst 의 맴버 별로 유형을 검사하고 맞으면 그에 맞게 _Src를 캐스팅하여 저장한다.

3. Shader 객체를 CMaterial 에서 관리하기 때문에 기존의 CShader 의 역할을 CMaterial 로 대체
-  <span style="color:yellow ">CMeshRender class 를 수정</span>하여 맴버변수인 m_pShader 와 그 역할을 CMaterial 형으로 선언한 변수 (m_pMaterial) 로 대체한다.
- <span style="color: yellow ">CLevelMgr class 를 수정</span>하여 기존의 CGraphicsShader 형 변수 와 그 쓰임을 CMaterial 형의 변수로 대체한다.
	- 첫번째 인덱스 