CEntity.h 에서

~CEntity() 가 virtual 로 선언되는 이유
-> 모든 object 들의 소멸자 순서는 생성과 ?반대로 되어야 하기 때문에?
-> virtual 소멸자를 사용하는 이유에 대하여 : 

 g_iNextID 는 어떤 용도로 쓰는 것이고 왜 static 으로 선언한거지?
->g_iID 는 모든 CEntity를 상속받은 클래스들에 부여된다. 이때 생성되는 자식 클래스 순서대로 다른 고유의 ID 를 가져야 하며 이를 위한 방법으로 ID 를 0으로 초기화 하고 CEntity 를 상속받는 클래스가 생성될 때마다 그 ID 에 1을 더하는 것이다. 따라서 g_iNextID 는 생성자에서 사용되어 그 전에 생성된 entity 자식 클래스보다 1이 더큰 고유 아이디를 갖게 된다.

 m_strName 은 그냥 wstring형 인데 왜 SetName 함수의 인자 _strName 은 const wstring& 형 인가?
->

virtual CEntity* Clone() = 0; 순수가상함수 선언으로 모든 자식 클래스는 클론 함수를 필수로 가져야 한다. 왜 모든 자식 클래스는 Clone() 함수를 가져야 하는다 이때 CEntity가 아닌 CEntity*인 이유는 무엇인가.

-> CEntity의 생성자 중 매개변수로 const CEntity& _other 를 받는 rjtdms 그 _other 로부터 똑같은 m_strName 을 얻고 g_iNextID 는 상관없이 증가되어 생성된다. 이때 _other 는 변형이 없어야 됨으로 const CEntity& 형으로 복사하고자 하는 entity 자식 클래스로 정의된 객체의 주소를 가져온다.

test.fx 에서 cbuffer 형 shader constant 에서 이름이 transform 인 이유와 맵버변수로 포지션 하나를 가지고 있는 이유는 무엇인가.
-> 

순수가상함수를 자식 클래스에서 반드시 override 해주어야 하는 이유는 ?
->

clone 을 하는 이유는
->

clone 에서 clone 에 대한 함수 정의가 없다는 오류가 뜨는 이유는?
->

g_ErrBlob; => m_ErrBlob 에 대해 컴파일이 실패할 경우의 객체인데 왜 실패하는 것에 대한 객체가 필요할까?
->

GetInst() 의 필요성과 쓰임
->