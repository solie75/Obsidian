0. clone 추가 -> define.h
0. global.h 에 assert.h 추가. 
2. Component 추가
	1.  define.h 에 Component_type 추가

3. Test.cpp 의 const buffer 추가
이때 const buffer 의 desc 에서 usage 를 dynamic 으로, CPUAccessFlags 를 D3D11_CPU_ACCESS_WRITE로 설정하고 기존의 vertex buffer 의 desc 의 usage 를 dynamic 에서 default 로, CPUAccessFlags 를 0으로 변경한다. 
->
	D3D11_BUFFER_DESC 에서 usage 가 default 일때 gpu 가 resource 를 일고 사용할 수 있지만 Map 을 통해서 읽거나 쓸 수 없다. 이와 달리 usage 가 dynamic 일 때, GPU 가 resource 를 읽고 사용하는 것은 같지만 Map 을 통해서 자료를 기록할 수 있다.
->
	D3D12 에서는 HEAP_TYPE 을 지정해야 하며 constant buffer 의 경우 upload heap 을 지정해야 한다고 나와있다. D3D11 에서 constant buffer를 생성하는 경우 D3D11_BUFFER_DESC 의 맴버인 Usage 를 Dynamic 으로 설정하는데 이때 어떤 heap 부분이 지정되는지는 03-17기준 모름
->
	vertex buffer가 아닌 const buffer 의 D3D11_BUFFER_DESC usage 를 dynamic 으로 하는 이유는 const buffer 를 사용하는 것이 매 프레임 별로 업데이트 되는 정점의 위치 등과 같은 데이터 변화에 더욱 효과적으로 메모리 처리가 가능하기 때문이다 [[Buffer#^1bccd9|상수 버퍼 사용 이유]]
->
	CPUAccessFlags는 usage와 조합하여 사용자가 CPU를 통해 접근하여 버퍼를 조작할 수 있는데 그 조작하는 역할을 상수 버퍼가 하게 되었으니 그에 맞는 usage 와 CPUAccessFlag 를 각 vertex 버퍼 와 constant 버퍼의 생성에 적용한다.
->
	기존의 vertex buffer 에 맞춰져 있던 map, memcpy, unmap 부분을 constant buffer 에 맞춰 g_CB로 바꾸고, map()을 FAILED 안으로 넣어 map 이 제대로 작동했을 때에만 memcpy 와 Unmap 이 호출되도록 한다.
->

4. Engine 라이브러리 Source 폴더에 Entity 클래스 추가
	