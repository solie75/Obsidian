# 제출 코드
```c++
int main()
{
	int arr[15][14]{};

	for (int i = 0; i < 14; i++)
	{
		arr[0][i] = i + 1;
	}
	for (int i = 0; i < 15; i++)
	{
		arr[i][0] = 1;
	}

	for (int i = 1; i < 15; i++)
	{
		for (int j = 1; j < 14; j++)
		{
			arr[i][j] = arr[i - 1][j] + arr[i][j - 1];
		}
	}

	int num = 0;
	cin >> num;

	for (int i = 0; i < num; i++)
	{
		int floor, room;
		cin >> floor >> room;
		cout << arr[floor][room-1] << "\n";
	}
}

```

# 타인 코드

```c++
#include <iostream>

using namespace std;

int main() {
	int t, n, k;
	double r, s;
	scanf("%d", &t);
	for (int i = 0; i < t; i++)
	{ 
		scanf("%d%d", &k, &n);
		r = 1;
		s = 1;
		for (int j = 0; j <= k; j++) 
		{
			r *= n + j;
			s *= j + 1;
		}
		
		printf("%lld\n", (long long)(r / s));
	} 
}
```

### 문제의 본질

**문제 개요**: 아파트에서 `k`층의 `n`호에 사는 사람의 수는 그 아래층, 즉 `(k-1)`층의 1호부터 `n`호까지 사람 수의 합입니다.  
예를 들어:

- `0층 n호`에 사는 사람은 단순히 그 호수와 동일한 수만큼의 사람이 있습니다. 즉, `0층 n호`에 사는 사람의 수는 `n`입니다.
- `1층 n호`에 사는 사람은 `0층 1호`부터 `n호`까지의 사람 수의 합입니다.

이를 좀 더 공식적으로 설명하면:

- `k층 n호에 사는 사람 수 = (k-1층 1호 + k-1층 2호 + ... + k-1층 n호)`

이런 패턴이 모든 층과 호에 대해 반복됩니다.

### 패턴 분석

#### 층을 차례로 생각해봅시다:

- `0층`: 각 호에 사는 사람의 수는 그냥 호수와 같습니다.  
    예: `0층 1호 → 1명, 0층 2호 → 2명, ..., 0층 n호 → n명`
    
- `1층`:
    
    - `1층 1호 → 0층 1호의 사람 수 = 1명`
    - `1층 2호 → 0층 1호 + 0층 2호 = 1 + 2 = 3명`
    - `1층 3호 → 0층 1호 + 0층 2호 + 0층 3호 = 1 + 2 + 3 = 6명`

이런 식으로 올라가면서, `k`층의 `n`호에 사는 사람의 수는 바로 아래 층의 1호부터 `n`호까지의 사람 수의 합으로 계산됩니다.

### 조합으로의 연결

이 문제를 해결하는 핵심은 "층과 호에 사는 사람의 수는 패턴에 따라 누적합"이라는 점에서 **조합(Combination)**의 개념이 자연스럽게 연결됩니다.

#### 왜 조합일까?

층을 높이면서, 각 층에서 n호에 사는 사람의 수는 이전 층의 사람 수의 누적합입니다. 이 문제를 **조합**으로 연결하는 이유는, 결국 특정 층과 호의 사람 수는 아래쪽에 있는 사람들을 중복 없이 선택해 나가면서 누적합을 계산하는 방식이기 때문입니다.

실제로, **k층 n호에 있는 사람의 수**는 **(n+k-1)개의 항에서 k개를 고르는 조합**으로 표현할 수 있습니다.

C(n+k−1,k)C(n+k-1, k)C(n+k−1,k)

이 공식은 **중복 조합**을 나타내는 공식입니다. 이 문제에서 중복 조합이 나오는 이유는, 0층부터 쌓인 사람들의 수를 계속 더해가면서 새로운 값을 계산하기 때문입니다.

### 예시로 살펴보기

- `0층`: 각 호에 사는 사람의 수는 호수와 동일하므로 1, 2, 3, ... n명의 사람이 있습니다.
    
- `1층`: 각 호는 아래층의 누적합으로 계산됩니다.
    
    - 1호에는 1명이 살고,
    - 2호에는 1 + 2 = 3명이 살고,
    - 3호에는 1 + 2 + 3 = 6명이 살고,
    - 이런 방식으로 계산됩니다.

이런 누적합 계산은 사실상 **조합 공식**으로 변환이 가능합니다. 조합 공식 C(n+k−1,k)C(n+k-1, k)C(n+k−1,k)는 **중복을 허용하는** 방식으로 아래층의 사람 수를 더하는 방법을 수학적으로 표현한 것입니다.

### 결론

- 문제에서 각 층과 호의 사람 수는 **중복 조합**의 계산과 일치합니다.
- 이 코드는 바로 그 조합 공식 C(n+k−1,k)C(n+k-1, k)C(n+k−1,k)을 계산해 주는 역할을 합니다.

따라서 "부녀회장이 될테야" 문제는 **조합 공식**으로 해결할 수 있습니다.



=> 조합은 여러개 중에 하나를 고르는 경우의 수이다. 위의 문제를 보고 해결을 위한 수식으로 조합 을 떠올리는 그 사고 과정이 이해 가지 않는다.

