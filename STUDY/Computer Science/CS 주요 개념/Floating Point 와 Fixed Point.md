10진수 정수를 2진수로 바꾸는 방법
10진수를 1이 될 때까지 계속 2로 나눠가면서 나머지를 구하고, 밑에서부터 거꾸로 읽는다.
10진수인 35를 2 진수로 나타내는 경우, 100011 이 된다.

![[Pasted image 20230111221410.png]]

정수를 위와 같은 방법으로 했다면 10진수로 표현된 실수를 2진수로 변환 할 수 있을까.
실수 (real number) 에 대하여 소수점을 기준으로 앞부분을 정수부, 뒷부분을 소수부 라고 한다. 이 때 정수부는 위와 같은 방법으로 2진법화 하고 소수부는 정수부의 정반대로 진행한다. 즉, 정수부에서는 10진수를 2로 나눠갔다면 소수부는 10진수에 2를 곱해간다. 그리고 정수부 변환 때에는 1이 나오면 종료했지만 소수부에서는 0이 나오면 종료하고 결과를 밑에서부터가 아닌 위에서부터 읽어준다.

예를 들어 0.625를 이진수로 변환하는 경우

1. $0.625\times2$ = 1.25 -> 1을 빼내고 나머지 0.25
2. $0.25 \times 2$ = 0.5 -> 0을 빼내고 나머지 0.5
3. $0.5 \times 2$ = 1.0 -> 1을 빼내고 나머지 0

나머지 0이 나왔으니 과정을 끝내고 빼낸 숫자들을 위에서 부터 읽어준다. 즉 0.625 -> 0.101이 된다.

(이를 통해 직관적으로 알 수 있는 것은  숫자가 n/(2의 배수)꼴의 분수로 표현되는 수일 수록 2진수로 바꿨을 때 자릿수가 적고, 그렇지 않을 수록 늘어난다는 것이다.)

# Fixed Point (고정 소수점)

10진수를 2진수로 바꾸면 그것을 그대로 적용하는 방식

7.625 라는 10진수 실수에 대ㅐ서  2진수로 변환하면 111.101이 된다. 이는 다음과 같다.
![[Pasted image 20230111222918.png]]
16 비트 체계를 쓴다고 가정할 때, 맨 앞의 1자리는 부호 비트(sign bit)로 0이면 양수, 1이면 음수를 뜻한다.
나머지 비트들은 소수점을 기준으로 정수부와 소수부를 표현하는 비트로 각각 나뉘는데, 소수점의 위치는 미리 정해 둔다.
소수부의 경우 앞에서부터 채우면 남은 뒷자리는 모두 0으로 설정한다.

이러한 Fixed Point 방식은 구현하기 편리하지만 사용하는 비트 수 대비 표현 가능한 수의 범위 또는 정밀도가 낮기 때문에 실수를 다뤄야 하는 범용 시스템에서는 잘 쓰이지 않고, 높은 정밀도가 필요없는 소규모 시스템에서는 간혹 쓰이기도 한다.

# Floating Point (부동 소수점)

2진수로 변환한 뒤

- 정규화
2진수를    $1.xxxxxx \times 2^n$    꼴로 변환하는 것을 말한다.
정수부에 1만 남을 때까지 소수점을 왼쪽(*정수부가 0일 경우엔 오른쪽.) 으로 이동 시키고 이동한 칸 수만큼 n 자리에 집어 넣으면 된다.
이와 같이 소수점이 떠다니며 움직인다 하여 '부동(浮動)'이다.
예를 들어 위의 111.101 을 정규화 하면 $1.11101 \times 2^2$ 가 된다.
지수와 가수의 개념을 활용한 이러한 추가적인 과정 때문에 단순히 bit 에 저장되는 정보로 판단하는 고정 소수점보다 더 많은 값을 표현할 수 있다. 이러한 연산은 CPU 의 연산 담당 모듈인 ALU 의 FPU(Floating Point Unit) 에서 처리한다. 

- IEEE  754 부동 소수점 표현 

부동 소수점 방식으로 실수를 저장하는 데 32 비트 혹은 64 비트를 사용한다. 

32 비트 기준
![[Pasted image 20230111232354.png]]

부호 비트(sign bit) 0이면 양수, 1이면 음수를 의미한다.
23 자리 가수부(Mantissa)는 정규화 결과 소수점 오른쪽에 있는 숫자들을 왼쪽 부터 그대로 넣으면 된다. 남는 자리는 0으로 채운다.
(참고 : 소수점 왼쪽은 정규화를 하면 무조건 1이기 때문에 신경쓰지 않고 표현도 하지 않는데, 이 1을 hidden bit 라고 부르기도 한다.)

지수부(Exponent)는 위의 정규화에서 n 에 해당하는 수를 2진수로 변환하여 넣는다.
이때 IEEE 표준에 따르면 지수부에 그대로 넣는게 아니라 'bias'라고 하는 지정된 숫자를 더한 다음 넣어야 한다. IEEE 표준으로 32 비트를 쓰는 경우 bias 는 127 이다. 따라서 n + 127 을 2진수로 바꾼 값이 지수부에 들어간다. 결론적으로 7.625 가 부동 소수전 기준으로 컴퓨터에 저장되는 값은 다음과 같다.

![[Pasted image 20230111233832.png]]

bias 를 쓰는 이유는 지수가 음수가 될 수 있기 때문이다.
예를 들어 0.000101 이라는 이진수 에 대하여 정규화를 하면 소수점을 오른쪽으로 밀어서 $1.01 \times 2^{-4}$ 가 된다.
이렇게 되면 bias 가 없을 경우 -4 를 지수부에 넣어야 하는 곤란한 상황이 생긴다. 지수용 부호 비트를 하나 더 만드는 것도 복잡하기에 127(bias)를 더해서 0~127구간은 음수, 128~255 구간은 양수를 표현하도록 만든것이다.

(참고 : 실제로는 0이랑 255는 0이나 0에 한없이 수렴하는 작은 수들, 무한대, NaN-Not a Number 같은 걸 표현하기 위해서 특별하게 지정되어 있기 때문에 일반적인 표현 범위에 포함되지 않으면 저런 수들을 표현할 때에는 정규화 방법이 적용되지 않는다.)

위와 같은 32 비트 체계를 32비트 단정도(single-Precision), 64 비트 체계를 62 비드 배정도(Double_Precision)이라고 한다. 64 비트 체계에서는 지수부가 11비트 가수부가 52비트이다. (지수부가 $2^{11}$, 즉 2048개의 수를 표현할 수 있으므로 0~1023 구간은 음수, 1024~2047 구간은 양수 지수를 의미하며 bias는 1023 이 된다.)

흔히 실수형 타입 중 float 은 32-bit Single-Precision, double 은 64-bit Double-Precision 에 해당한다. 

## 정밀도(Precision)

정밀도란, 측정이나 계산의 결과가 서로 얼마나 가까운지 나타내는 값이다. 부동 소수점 또는 고정 소수점 방식에서 정밀도는 간단하게 소수를 표현하기 위한 비트 수 (bit Length)로 여겨 진다.

십진수 0.1 을 이진수로 나타내는 경우 무한 소수가 되기 때문에 한정된 bit 자릿수까지만 저장하고 나머지는 손실된다.(이진법에서는 1이면 반올림된다.) 이때 반올림으로 인하여 실제 십진법 0.1 과 그것을 이진법으로 나타낸 값은 차이가 나게 되는데 이는 해당 이진법 값에 사칙연산을 처리할 수 록 그 차이가 커지게 된다.

## Rounding errors

10진수를 2진수로 변환 할 때 2진수가 무한 소수 인경우 메모리 제한으로 인해 정해진 가수부 길이 만큼 소수부분을 한정하고 그 수는 2진수로 변환 되기 전의 10 진수와는 다른 수이다. 이 다름을 반올림 오류(rounding error)라 한다.

```c++

#include <iostream>
#include <iomanip>

int main()
{
	std::cout << std::setprecision(17);

	double d1(1.0);
	std::cout<<d1<<std::endl;

	double d2(0.1+0.1+0.1+0.1+0.1+0.1+0.1+0.1+0.1+0.1);
	std::cout<<d2<<std::endl;
}

// output
1
0.99999999999999989 (:rounding error)
```

## Reference

https://gsmesie692.tistory.com/94 (부동 소수점과 고정 소수점 기본 개념)
http://arkainoh.blogspot.com/2017/11/fixed-point.html (고정 소수점 심화 개념)
https://www.youtube.com/watch?v=vOO-oLS0H68 (정밀도)
https://notjustmoney.github.io/2021/12/19/floating-point-precision/ (부동소수점과 정밀도)
https://boycoding.tistory.com/152 (반올림 오류 및 NaN , Inf)