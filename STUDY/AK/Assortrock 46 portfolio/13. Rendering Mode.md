1. Graphic.h 에 Rendering Mode 에 대한 enum 추가
```c++
enum class eRenderingMode
{
	Opaque,
	CutOut,
	Transparent,
	End,
};
```

1. Opaque : 불투명 , 해당 material 은 빛이 완전히 투과하지 않고 객체가 다른 객체들을 완전히 가리도록 만든다.
2. Cutout : 잘라내기 , 텍스쳐의 알파 채널 값을 기반으로 일부 영역을 제외한 부분을 투명하게 만드는 방식이다. 이 모드를 사용하면 material 이 불투명한 부분과 완전히 투명한 부분만 남기고, 중간값을 가진 알파 값을 기준으로 선택적으로 제거할 수 있다. 
3. Transparent : 투명, 빛이 완전히 투과하여 객체가 뒤의 객체를 부분적으로 표시하도록 만든다. 이 모드는 유리, 물 등의 투명한 표면을 만들  때 사용된다. 투명 material 은 주로 알파 채널 값에 따라 텍스쳐의 투명도를 조절하며, 다른 물체와 겹칠 때 깔끔하게 블랜딩 될 수 있도록 설정해야 한다.

2. Material 이 RenderingMode 를 변수로 갖는다.
```c++
// CMaterial.h
private:
...
eRenderingMode mRenderMode;

public:
...
void SetRenderMode(eRenderingMode mode) { mRenderMode = mode; }
    eRenderingMode GetRenderingMode() { return mRenderMode; }
```

3. Camera Component 에서 Camera 객체 이외의 game 객체들을 eRenderingMode 별로 구분하여 관리한다.
```c++
// CCamera class 맴버 변수 추가
private :
...
std::bitset<(UINT)eLayerType::End> mLayerMask;
std::vector<CGameObject*> mOpaqueGameObjects;
std::vector<CGameObject*> mCutOutGameObjects;
std::vector<CGameObject*> mTransparentGameObjects;
```

```c++
// CCamera claa 맴버 함수 추가
public :
	void SortGameObjects();
	void RenderOpaque();
	void RenderCutOut();
	void RenderTransparent();
	
	void TurnLayerMask(eLayerType type, bool enable = true);
	void EnableLayerMasks() { mLayerMask.set(); }
	void DisableLayerMasks() { mLayerMask.reset(); }
```

```c++
// CCamera.cpp
CCamera::CCamera()
	: CComponent(eComponentType::Camera)
	, mType(eProjectionType::OrthoGraphic)
	, mAspectRatio(1.0f)
	, mNear(1.0f)
	, mFar(1000.0f)
	, mSize(5.0f)
	, mLayerMask{}
	, mOpaqueGameObjects{}
	, mCutOutGameObjects{}
	, mTransparentGameObjects{}
{}

void CCamera::Initialize()
{
	EnableLayerMasks();
}

void CCamera::Render()
{
	RenderOpaque();
	RenderCutOut();
	RenderTransparent();
}

void CCamera::RenderOpaque()
{
	for (CGameObject* gameObj : mOpaqueGameObjects)
	{
		if (gameObj == nullptr)
			continue;

		gameObj->Render();
	}
}

void CCamera::RenderCutOut()
{
	for (CGameObject* gameObj : mCutOutGameObjects)
	{
		if (gameObj == nullptr)
			continue;

		gameObj->Render();
	}
}

void CCamera::RenderTransparent()
{
	for (CGameObject* gameObj : mTransparentGameObjects)
	{
		if (gameObj == nullptr)
			continue;

		gameObj->Render();
	}
}

void CCamera::TurnLayerMask(eLayerType type, bool enable)
{
	mLayerMask.set((UINT)type, enable);
}
```

4. CScene 에 GetLayer() 추가
```c++
// CScene.h
public:
...
CLayer& GetLayer(eLayerType type) { return mLayers[(UINT)type]; }
```

5. CLayer 에 GetGameObjects() 추가
```c++
const std::vector<CGameObject*> GetGameObjects()
{
	return mGameObjects;
}
```

6. CMeshRender 에 GetMaterial() 추가
```c++
public:
...
std::shared_ptr<CMaterial> GetMaterial(){ return mMaterial; }
```

7. CCamera.cpp 에 rendering mode 에 따른 객체 정렬 함수 추가
```c++
// CCamera.h
public:
...
void SortGameObjects();

// CCamera.cpp
void CCamera::SortGameObjects()
{
	mOpaqueGameObjects.clear();
	mCutOutGameObjects.clear();
	mTransparentGameObjects.clear();

	CScene* scene = CSceneMgr::GetInst()->GetActiveScene();
	for (size_t i = 0; i < (UINT)eLayerType::End; i++)
	{
		if (mLayerMask[i] == true)
		{
			// Mask 가 true 인 Layer 의 모든 게임 오브젝트들을 가져온다.
			CLayer& layer = scene->GetLayer((eLayerType)i);
			const std::vector<CGameObject*> gameObjs = layer.GetGameObjects();

			for (CGameObject* obj : gameObjs)
			{
				CMeshRender* mr = obj->GetComponent<CMeshRender>(eComponentType::MeshRender);
				if (mr == nullptr)
				{
					continue;
				}
				
				std::shared_ptr<CMaterial> mt = mr->GetMaterial();
				eRenderingMode renderMode = mt->GetRenderingMode();

				switch (renderMode)
				{
				case eRenderingMode::Opaque :
					mOpaqueGameObjects.push_back(obj);
					break;
				case eRenderingMode::CutOut :
					mCutOutGameObjects.push_back(obj);
					break;
				case eRenderingMode::Transparent :
					mTransparentGameObjects.push_back(obj);
					break;
				default :
					break;
				}
			}
		}
	}
}
```

Create & Load Scene
```c++
// CSceneMgr.h
#pragma once
#include "yaScene.h"

namespace ya
{
	class SceneManager
	{
	public:
		static void Initialize();
		static void Update();
		static void LateUpdate();
		static void Render();
		static void Release();
		
		template <typename T>
		static bool CreateScene(std::wstring name)
		{
			T* scene = new T();

			std::map<std::wstring, Scene*>::iterator iter
				= mScenes.find(name);

			if (iter != mScenes.end())
				return false;

			mScenes.insert(std::make_pair(name, scene));
			mActiveScene = scene;
			scene->Initialize();
			return true;
		}
		static Scene* LoadScene(std::wstring name);
		static Scene* GetActiveScene() { return mActiveScene; }

	private:
		static Scene* mActiveScene;
		static std::map<std::wstring, Scene*> mScenes;
	};
}

```

```c++
// CSceneMgr.cpp
Scene* SceneManager::LoadScene(std::wstring name)
	{
		std::map<std::wstring, Scene*>::iterator iter
			= mScenes.find(name);

		if (iter == mScenes.end())
			return nullptr;

		mActiveScene->OnExit();
		mActiveScene = iter->second;
		mActiveScene->OnEnter();

		return iter->second;
	}
void SceneManager::Release()
	{
		for (auto& iter : mScenes)
		{
			delete iter.second;
			iter.second = nullptr;
		}
	}
```