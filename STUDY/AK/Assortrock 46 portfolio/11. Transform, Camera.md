지금까지는 Mesh 와 Texture 를 출력함에 있어 공간적으로 보면

- 화면 출력 버퍼의 생성
SetWindowPos() 로 윈도우 창의 크기 를 정한다.
RSSetViewports() 로 뒷 버퍼의 영역을 지정한다.
뒷 버퍼를 CreateRenderTargetView() 와 CreateDepthStencilView() 로 그린다.
SwapChain 으로 두 개의 버퍼를 사용하여 화면에 윈도우 창만큼의 버퍼를 번갈아 출력한다.

- 공간적 개념
하나의 객체(게임 내의 오브젝트) 는 각자만의 공간을 가지고 있다. 이를 local 공간이라 한다. 이러한 객체들이 모인 공간을 world 공간이라 한다. 월드 공간에 카메라를 배치하여 카메라가 보는 장면을 기준으로 화면에 출력한다. 이때 카메라의 시야에 잡히는 3D 적 공간을 camera 공간 또는 view 공간이라고 하며 이 3D 적 공간이 출력 되기 위하여 깊이적으로 압축되어 2D 로 표현된 평면적 공간을 screen 공간이라 한다. 이때 카메라 가 가지는 시야의 종횡비와 출력될 윈도우 창의 종횡비가 다를 수 있다. 이를 위해 NDC 좌표계를 도입하여 카메라의 화면이 가로나 세로로 비율이 변형되지 않고 출력되게 한다.

Transform 은 객체를 local 공간에서 Screen 공간까지의 변형을 위한 Component 이다.

# ConstantBuffer

ConstantBuffer 를 하나의 클라스로 두고 사용한다.

- 

# World 변환

1. Component 폴더에 Transform 폴더 생성 -> 해당 폴더에 CTransform class 추가

```c++
// CTransform.h
#include "CComponent.h"
#include "Graphic.h"
#include "CConstantBuffer.h"

class CGameObject;

class CTransform :
    public CComponent
{
private:
	Vector3 mPosition;
	Vector3 mRotation;
	Vector3 mScale;

	Vector3 mUp;
	Vector3 mFoward;
	Vector3 mRight;

	Matrix mWorld;

	CConstantBuffer* mTransformCB;

public:
	CTransform();
	~CTransform();

	virtual void Initialize() override;
	virtual void Update() override;
	virtual void LateUpdate() override;
	virtual void Render() override;

	void CreateConstantBuffer();

	void SetPosition(Vector3 position) { mPosition = position; }
	void SetRotation(Vector3 rotation) { mRotation = rotation; }
	void SetScale(Vector3 scale) { mScale = scale; }

	void SetPosition(float x, float y, float z) { mPosition = Vector3(x, y, z); }
	void SetRotation(float x, float y, float z) { mRotation = Vector3(x, y, z); }
	void SetScale(float x, float y, float z) { mScale = Vector3(x, y, z); }

	Vector3 GetPosition() { return mPosition; }
	Vector3 GetRotation() { return mRotation; }
	Vector3 GetScale() { return mScale; }

	Vector3 Foward() { return mFoward; }
	Vector3 Right() { return mRight; }
	Vector3 Up() { return mUp; }

	CConstantBuffer* GetTransformCB() { return mTransformCB; }
};
```

```c++
#include "CTransform.h"
#include "CGameObject.h"


CTransform::CTransform()
	: CComponent(eComponentType::Transform)
	, mPosition(Vector3::Zero)
	, mRotation(Vector3::Zero)
	, mScale(Vector3::One)
{
	mTransformCB = new CConstantBuffer();
}

CTransform::~CTransform(){}
void CTransform::Initialize(){}
void CTransform::Update(){}

void CTransform::LateUpdate()
{
	mWorld = Matrix::Identity;

	Matrix scale = Matrix::CreateScale(mScale);

	Matrix rotation;
	rotation = Matrix::CreateRotationX(mRotation.x);
	rotation *= Matrix::CreateRotationY(mRotation.y);
	rotation *= Matrix::CreateRotationZ(mRotation.z);

	Matrix position;
	position.Translation(mPosition);

	mWorld = scale * rotation * position;

	mUp = Vector3::TransformNormal(Vector3::Up, rotation);
	mFoward = Vector3::TransformNormal(Vector3::Forward, rotation);
	mRight = Vector3::TransformNormal(Vector3::Right, rotation);
}

void CTransform::Render() {}

void CTransform::CreateConstantBuffer()
{
	TransformCB trCB = {};
	trCB.mWorld = mWorld;

	mTransformCB->InitConstantBuffer(sizeof(TransformCB), eCBType::Transform, &trCB);
}
```
- World 변환 생성

# Camera (VIew, Projection)

- Component 폴더에 Camera 폴더 생성 -> 해당 폴더에 CCamera 클라스 추가

```c++
// CCamera.h
#include "CComponent.h"
#include "CTransform.h"
#include "CDevice.h"

class CCamera :
    public CComponent
{
public:
	enum class eProjectionType
	{
		Perpective,
		OrthoGraphic,
		None,
	};

private:
	static Matrix mView;
	static Matrix mProjection;

	eProjectionType mType;
	float mAspectRatio;
	float mNear;
	float mFar;
	float mSize;

public:
	CCamera();
	~CCamera();

	virtual void Initialize() override;
	virtual void Update() override;
	virtual void LateUpdate() override;
	virtual void Render() override;

	bool CreateViewMatrix();
	bool CreateProjectionMatrix(eProjectionType type);

	static Matrix GetViewMatrix() { return mView; }
	static Matrix GetmProjectionMatrix() { return mProjection; }
};

Matrix CCamera::mView =  Matrix::Identity;
Matrix CCamera::mProjection = Matrix::Identity;
```

```c++
// CCamera.cpp
#include "CCamera.h"
#include "CGameObject.h"

CCamera::CCamera()
	: CComponent(eComponentType::Camera)
	, mType(eProjectionType::OrthoGraphic)
	, mAspectRatio(1.0f)
	, mNear(1.0f)
	, mFar(1000.0f)
	, mSize(5.0f)
{}

CCamera::~CCamera(){}

void CCamera::Initialize(){}

void CCamera::Update(){}

void CCamera::LateUpdate()
{
    CreateViewMatrix();
    CreateProjectionMatrix(mType);
}

void CCamera::Render(){}

bool CCamera::CreateViewMatrix()
{
	CTransform* tr = GetOwner()->GetComponent<CTransform>(eComponentType::Transform);
	Vector3 pos = tr->GetPosition();

	// View Translate Matrix
	mView = Matrix::Identity;
	mView *= Matrix::CreateTranslation(-pos);

	// View Rotation Matrix
	Vector3 up = tr->Up();
	Vector3 right = tr->Right();
	Vector3 foward = tr->Foward();

	Matrix viewRotate;
	viewRotate._11 = right.x;	viewRotate._12 = up.x;	viewRotate._13 = foward.x;
	viewRotate._21 = right.y;	viewRotate._22 = up.y;	viewRotate._23 = foward.y;
	viewRotate._31 = right.z;	viewRotate._32 = up.z;	viewRotate._33 = foward.z;
	mView *= viewRotate;

	return true;
}

bool CCamera::CreateProjectionMatrix(eProjectionType type)
{
	float width = (float)(CDevice::GetInst()->GetDeviceWidth());
	float height = (float)(CDevice::GetInst()->GetDeviceHeight());
	mAspectRatio = width / height;

	if (type == eProjectionType::OrthoGraphic)
	{
		float OrthorGraphicRatio = mSize / 1000.0f; 
		width *= OrthorGraphicRatio;
		height *= OrthorGraphicRatio;
		mProjection = Matrix::CreateOrthographicLH(width, height, mNear, mFar);
	}
	else
	{
		mProjection = Matrix::CreatePerspectiveFieldOfViewLH(XM_2PI / 6.0f, mAspectRatio, mNear, mFar);
	}
	return true;
}

```

DirectX의 CreateOrthographicLH 함수에 전달할 가로와 세로 값은 투영된 화면 공간의 크기를 나타낸다.	이 값은 실제 윈도우의 크기와는 관련이 없으며, 화면에 표시할 3D 객체의 크기 및 비율을 결정한다. CreateOrthographicLH 함수에 전달할 가로와 세로 값은 실제 윈도우 크기와는 독립적으로 설정되어야 한다.

View  와 Projection 을 static 으로 설정하여 Transform 에서 접근할 수 있게 한다.

- CTransform::CreateConstantBuffer() 에서
```c++
void CTransform::CreateConstantBuffer()
{
	TransformCB trCB = {};
	trCB.mWorld = mWorld;
	trCB.mView = CCamera::GetViewMatrix();
	trCB.mProjection = CCamera::GetmProjectionMatrix();

	mTransformCB->InitConstantBuffer(sizeof(TransformCB), eCBType::Transform, &trCB);
}
```

- Scene 에서 Camera 객체 추가
```c++
void CPlayScene::Initialize()
{
	CGameObject* player = new CGameObject();
	AddGameObject(eLayerType::Player, player, L"Link");
	CMeshRender* mr = player->AddComponent<CMeshRender>();
	mr->SetMesh(CResourceMgr::Find<CMesh>(L"Mesh"));
	mr->SetMaterial(CResourceMgr::Find<CMaterial>(L"Material"));

	CGameObject* mainCamera = new CGameObject();
	AddGameObject(eLayerType::Player, mainCamera, L"MainCamera");
	mainCamera->GetComponent<CTransform>(eComponentType::Transform)->SetPosition(Vector3(0.0f, 0.0f, -10.0f));
	CCamera* camComponent = mainCamera->AddComponent<CCamera>();
}
```