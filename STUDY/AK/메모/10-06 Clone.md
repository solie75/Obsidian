복사생성자가 기본일 때 생기는 문제

컴파일러가 만든 자동 복사생성자 은 기존의 요소들을 그대로 옮기기 때문에 같은 위치 같은 크기 등의 요소는 괜찮을 지 몰라도 . 같은 component 를 가리키게 되는 것은 같은 충돌체를 쓰고 같은 RigidBody를 사용한다는 것이므로 .

Q. 왜 복사를 하는 거지?

어떠한 객체를 복사하고 싶은 때에는 Clone 이라는 함수를 호출한다.

Centity 에서 clone 함수를 순수가상함수 선언한다.
-? CEntity를 상속받는 모든  class 에서  Clone 함수를 선언한다.

생성자에서 복사생성자를 생성
이때 그대로 가져올 것과 아닌 것들을 구분하여 아닌 것들은 nullptr 처리 할 것
-> 깊은 복사

상속 구조에서 
기본생성자에서 상위 클래스에 대한 별다른 코드가 없으면 부모 클라스의 기본 생성자를 호출한다. 따라서 깊은 복사 생성자로 사용자가 커스텀을 하고 싶다면 부모 클라스의 깊은 복사 생성자를 자식 클래스의 생성자 초기화 파트에서 부모 클래스 깊은 복사 생성자를 호출해야한다.

virtual CPlayer* Clone() { return new CPlayer(*this)}

클론과 클론 비활성화 def.h 에 선언

component 에서  맴버 변수로 객체를  const 로 가지고 있기 때문에 깊은 복사를 하려고 할때  복사된 컴포넌트가 똑같은 객체를 가리키는 경우가 생긴다.
-> 