파티클

따로 지정해 줘야 하는 메쉬와 다르게 파티클은 생성되는 순간 메쉬가 정해져 있는 데로 생성 된다.

현재 설정 해야 하는게 많아서 생성자에서 하드코딩으로 생성 해 놓음

파티클이 변경되는 기준점이 되는 DT 값을 gpu 에 바인딩 되어 있는 Global 상수 버퍼를 사용한다.
따라서 Constant buffer 클래스에서 Compute Shader 에 대한 Update 를 해준다. ( CConstantBuffer::UpdateData_CS() )

바인딩은 모든 렌더링 파이프 라인 단계에 한번에 되는 것이 아니라 해당 바인딩 데이터를 필요로 하는 각 렌더링 파이프 라인 단계별로 바인딩 되어야 한다. 예를 들어 Vertex Shader 단계에만 바인딩 되었다면 (VSSetConstantBuffers())  HS, DS, GS, PS 에서는 해당 바인딩이 존재하지 않고 VS 단계에서 바인딩 되었던 슬롯이 빈 상태 라는 뜻이다.

구조화 버퍼는 생성과 동시에 초기 데이터를 넣을 수 있다.
예를 들어 삼천개의 파티클에 대한 배열을 구조화 버퍼로 한다고 할때 그 구조체만 gpu 상에 바인딩 해놓고 그 초기화 데이터를 전달하는 것은 오버 헤드이기에 Subresource Data 에 데이터를 설정하고 CreateBuffer()로 구조체 버퍼를 생성할 때 이미 데이터를 초기화 한다.


파티클 과정

객체가 Particle System Component 를 갖는다. 해당 component 의 생성자에서 SetMesh() 로 입자 메쉬를, SetMaterial() 로 파티클 전용 재질을 설정한다.

Compute Shader로 Particle 을 Update 한다.
구조체 버퍼를 새로 생성하고 이전에 하드코딩 해둔 파티클 설정 정보를 가지고 Create 함수를 호출한다.
Create() 호출에서 파티클 구조체의 사이즈와 파티클 최대 개수 를 곱하여 버퍼의 크기를 구한다. 이때 버퍼의 크기는 16바이트 의 배수여야 한다. => 이때문에 파  티클의 구조체를 16의 배수로 하기 위해서 패딩이 있는 것. 
이때 초기화 데이터를 같이 전달하여 생성 될 때 데이터를 초기화 할 수 있다. D3D11_SubResource_Data 를 히용한다.

구조화 버퍼를 만들 때 Usage 바인딩 설정 요소 에 있어서
Default 의 경우 : 한번 만들면 건들 수 없다.
Dynamic + CpuAccessProcee;write : 이미 만들어진 버퍼를 덮어 쓰기 가능
stayzing + '' Read : 버퍼를 읽어 들일 수 있음

구조화 버퍼를 Defualt 로 선언하고 데이터를 업데이트 하기 위해서 해당 버퍼를 write 또는 read 둘 중 하나만 가능하게 해 놓는다면 해당 구조화 버퍼를 u Register 에 바인딩 할 수 없다.

compute shader 에서 u register 로 받아야 역으로 compute shder 코드에서 쓰레드가 자기가 담당하고 있는 파티클  에 접근해서 수정 가능
이렇게 하기 위해서는 unordered access view 를 이용하여 u register 에 바인딩 해야 한다.
그리고 이것은 해당 버퍼의 Usage 가 default 일 때에만 가능하다.

때문에 읽고 쓰는 것은 다른 보조 버퍼를 두어서 그 버퍼를 통해 이루어 져야 한다.
쓰는 경우 구조체 버퍼와 같은 버퍼 를 하나 준비하고 해당 버퍼에 write 하고 구조체 버퍼에 복사한다.
읽는 경우에는 구조체 버퍼와 같은 크기의 버퍼를 하나 준비하고 해당 버퍼에 구조체 버퍼의 내용을 복사한뒤 준비한 버퍼를 읽어들인다.
CStructureBuffer::SetData(), CStructureBuffer::GetData();

particle_update.fx 에서 CS_ParticleUpdate(int3 \_ID : SV_DispatchThreadID) 함수는 하나의 쓰레드를 입력 받아서 담당 파티클을 업데이트 한다.

이것을 쓰레드 그룹을 어떻게 구성했느냐에 따라서 ParticleUpdateShader::UpdateDAta()의 그룹수 계산 부분에서 몇개 필요한지 계산한다.


현재 파티클의 사용의 경우 3000개의 잠재적인 파티클중 누구는 활성화 되어 있고 누구는 활성화 되지 않는다.  이때 새로운 활성화 시작 명령이 떨어 졌을 때 어느 파티클을 활성화 시키고 전체 적인 렌더링은 어떻게 할 것인가?

동기화 문제 : InterlockedCompareExchange() 함수로 해결(어는 파티클을 활성화 할것인지 결정해준다.)한다.
```c++
InterlockedCompareExchange(destination, compare, exchange, out originalValue);


- `destination`: 업데이트를 수행할 변수의 주소.
- `compare`: 현재 변수의 값과 비교할 값.
- `exchange`: 변수의 값이 `compare`와 일치할 때 대체할 값.
- `originalValue`: 원래의 변수 값이 저장되는 변수. 이 값은 `compare`와 일치하는 변수의 원래 값.

1. `destination`의 현재 값이 `compare`와 같으면, `destination`의 값을 `exchange`로 변경(대입)
2. 그렇지 않으면, 아무 작업도 수행하지 않고 `destination`의 현재 값을 `originalValue`에 저장
```

렌더링 문제 : 

m_RWBuffer 로 해당 틱에서 몇 개의 파티클이 활성화 되어야 하는지 알린다.

스폰 카운터 가 10 이라고 가정할 때 (이번 tick 에서 10 개의 파티클을 활성화 시키려고 할 때) 다음의 함수를 호출한다.
```c++
#define SpawnCount 10 //(활성화 시키려는 파티클 개수)
int orgvalue = SpawnCount;
int outvalue = 0;
InterlockedCompareExchange(SpawnCount, orgvalue, SpawnCount - 1, outvalue);

1. 
```


