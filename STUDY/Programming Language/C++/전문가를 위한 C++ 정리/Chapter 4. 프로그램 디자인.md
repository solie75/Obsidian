프로그램 디자인 문서는 일반적으로 다음 두 부분을 포함한다.
1. 전체 프로그램을 구성하고 있는 서브 시스템 
   각 서브 시스템 간의 종속성 및 인터페이스. 각 서브 시스템 간의 데이터 흐름과 입출력, 전체적인 스레드 활용 모델을 설명하는 부분
2. 서브시스템별 상세 사항 : 클래스 구성, 계층도, 데이터 구조, 알고리즘, 개별 스레드 활용 모델, 에러 처리 방법을 설명하는 부분

하지만 결국 가장 중요한 것은 코드를 한 줄이라도 작성하기 전에 만들어진 프로그램에 대해 생각하는 기회가 있어야 한다는 것이다.

C++ 에서 근본적인 디자인 원칙은 추상화 와 재사용이다.

- 추상화
  내부 구형과 외부 인터페이스를 분리하여 사용하는 것이다. 이를 통해서 함수나 메서드, 클라스를 사용하는 사용자는 그 코드 전체와 알고리즘 과정을 알지 못해도 그 기능을 사용할 수 있다.
- 재사용
  프로그램을 작성할 때는 클래스, 알고리즘, 데이터 구조를 재사용할 수 있게 디자인 해야한다.
  라이브러리, 프레임 워크, 클라스 등을 재사용할 때 활용할 방식과 그 외에 직접 개발하는 부분이 무엇인지를 고려해야한다.
  만약 함수가 메모리 포인터를 리턴한다면 해당 메모리 해제는 어떻게 할 것인가. 호출자인가 아니면 라이브러리인가. 라이브러리에서 할당하는 메모리 포인터는 스마트 포인터로 감싸서 이용하도록 하자.

- Big-O 표기법
알고리즘의 실행 소요 시간을 입력 데이터의 크기에 대한 함수로 나타낸 것으로 알고리즘 복잡도라고 한다.
표기는 대표적으로 다음과 같다. O(n) -> 여기에서 O 는 Big-O 표기법이라는 것을 나타내고 n은 입력 데이터 크기를 나타낸다.  즉 O(n)은 알고리즘의 실행 소요 시간이 입력 데이터의 크기에 정비례하는 함수임을 표현한다. 

대표적인 알고리즘 복잡도
1. 상수(Constant) , O(1) , 대상 데이터 크기와 관계없이 항상 수행 시간이 동일하다. (예, 배열의 항목 하나에 인덱스 값으로 접근)
2. 로그(Logarithmic), O(log n), 입력 데이터 크기에 따라 실행 시간이 지수 2의 로그 함수에 비례한다. (예, 이미 정렬된 리스트에서 바이너리 탐색으로 특정 항목 탐색)
3. 선형(Linear), O(n), 실행 시간이 입력 데이터 크기에 비례하다. (예, 정렬되지 않은 리스트에서 특정 항목 탐색)
4. 로그 선형 배수(Linear Logarithmic), O(n log n), 실행 시간이 입력 데이터 크기의 로그 값의 선형 곱에 비례한다. (예, 병합 정렬)
5. 제곱(Quadratic), O(n^2), 실행시간이 입력 데이터 크기의 제곱에 비례한다. (예, 선택 정렬과 같이 성능이 낮은 알고리즘)
6. 지수(Exponential), O(2^n), 실행 시간 

- 라이브러리 사용에 대하여
1. 플랫폼 지원을 확인한다.
2. 법적 문제 확인. 같은 조직 내의 라이브러리 또한 기술 지원 문제를 확인한다.
3. 새로운 라이브러리 혹은 프레임 워크를 사용함에 앞서 먼저 간단한 프로토 타입을 구현한다. 이때는 단순 시험성으로 실제 개발의 완성도를 목표로 하지 않는다.


- 실습 : 체스 프로그램 디자인

1. 요구사항
   디자인에 들어가기 전에 프로그램의 기능과 성능에 대해 요규되는 조건을 명확하게 정리하는 것이 중요하다.
2. 디자인 단계
   - 소프트웨어 산업 표준에서 UML(unified modeling language) 형식을 따라 소프트웨어 설계 도면을 작성하도록 권장되고 있다.
   - 우선 프로그램을 일반적인 기능을 기준으로 서브 시스템 별로 분할하고 각 서브시스템간 인터페이스와 상호연동을 정의한다.  이는 단지 프로그램의 구성요소와 그 연계방식에 대한 감을 잡는 것을 목표로 한다.
   - 체스 게임 프로그램의 디자인은 '데이터의 저장부와 표현부를 분리하는 모델-뷰-컨트롤러(model niew controller) 패러다임' 으로한다.
   - MVC 에서
     model 은 다루어야 할 데이터의 집합 이다.
     view 는 model 에 대한 가시적인 표현이다.
     controller 는 이벤트에 맞추어 데이터를 변경하는 코드를 말한다.
 ![[Pasted image 20231107145748.png]]

MVC 디자인의 관점에서 위의 분류는 다음과 같다.
Model : ChessBoard, ChessPiece
view : ChessBoardView, ChessPieceView
controller : Player

3. 스레드 사용 모델 선택
   알고리즘의 어떤 루프에 스레드를 사용하는지에 대한 것은 이르지만 상위 수준에서 몇 개의 스레드를 사용할지, 스레드 간에 어떤 상호 연동을 할 지 생각한다., 상위 수준 스레드의 예로는 UI 스레드, 오디오 재생 스레드, 네트워크 통신 스레드 같은 것들이 있다. 
   멀티 스테드 디자인에서 스레드간 데이터 공유를 되도록 피해서 디자인하고 피할 수 없다면 스레드 락 메커니즘을 사용해야 한다.
   프로그램이 몇 개의 확연히 구분되는 작업으로 나눠지고 각 작업이 병렬적으로 수행되어야 한다면 멀티스레드를 이용하는 것이 좋은 선택이다.

4. 클래스 대상 식별, 데이터 구조, 알고리즘, 각 서브 시스템 패턴
   각 서브 시스템의 세부적 부분 검토. (+ 각 서스시스템의 어떤 부분을 클래스화 할지 검토, 보통 서브 시스템 각각이 클래스가 될 때가 많다.)

5. 각 서브시스템의 에러 처리
   각 서브 시스템의 에러 처리 방법에 대해 기술한다.
   이때 대상이 되는 에러처리는 시스템 에러(ex 메모리 할당 실패)와 사용자 에러(사용자의 잘못된 입력) 모두를 말한다.
   각 서브시스템 별로 에러 처리에 익셉션을 사용할 것인지, 사용한다면 어떤 익셉션을 사용할 것인지 결정해야 한다.