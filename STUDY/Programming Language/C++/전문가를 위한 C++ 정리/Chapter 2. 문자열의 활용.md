C 의 NULL 종결 스타일의 단순 아스키 문자 배열은 버퍼 오버플로 같은 보안 위험등을 야기한다. C++ 에서는 std::string 클래스를 제공하여 C 의 문자열 스타일의 단점을 피한다.

- C 스타일의 문자열
null 문자 ('\\0') 으로 채워지고 코드에선 NULL 문자를 체크하여 문자열의 끝임을 판단한다. null 문자는 NUL 로 알려져 있다. L 이 두번이 아닌 한번만 쓰인다. NUL 은 NULL 포인터와는 다르다. 
\*  문자열 마지막에 '\\0' 문자를 위한 공간 할당을 빼먹지 말하야 한다.  예를 들어 문자열 'hello' 는 5글자이지만 실제 필요한 메모리는 '\\0'을 포함한 6글자 분량이다.

- C++ 에서의 C 문자열 처리
C++ 에서는 C의 여러 문자열 처리 함수를 내장하고 있다. 이 함수들은 <\cstring> 헤더 파일에 정의되어 있다. 기본적으로 이 함수들은 메모리 관리를 하지 않는다. 예를 들어 strcpy() 함수를 사용하여 A 문자열 포인터를 받아 B 문자열에 복사할 때 B 문자열이 적절한 메모리 공간을 가졌는지 신경쓰지 않는다. [[C 스타일 문자열 활용]]

- 문자열 리터럴
  cout << "hello" << endl; 에서 hello 를 문자열 리터럴 이라 한다. 코드에 직접 입력된 상수 값이다. 문자열 리터럴은 읽기 전용 메모리에 할당된다. c++ 에서는 공직석으로 문자열 리터럴을 크기 n 의 const char 배열 타입으로 부른다. (const 로 강제하지는 않아서 const char* 대신 char\*이 사용가능 하다) 하지만 문자열 리터럴을 변경하는 것은 정의되어 있지 않기때문에 되도록 const 로 지정하여 변경 시도에 대하여 컴파일 차원에서 에러를 일으키게한다.
  
  문자열 리터럴은 문자 배열 (char[]) 의 초기값으로 이용가능하다. 이 경우 컴파일러가 자동으로 해당 배열의 크기를 문자열과 널 마크를 복제해 담을 수 있을 만큼 할당한다. 또한 해당 배열은 읽기 전용 메모리에 두지 않는다.
  ```c++
  char arr[] = "game";
  arr[1] = 'a'; // 배열 내용이 수정가능하다.
```


- C++ string 클래스
[[cstring]]
c++  프로젝트를 시작할 때는 프레임워크 호환성 문제나 특정 상황에서 커스텀 문자열 타입이 필요한 경우가 있기 때문에 어떤 문자열 타입을 사용할지 장기적 관점으로 보고 정해야 한다.