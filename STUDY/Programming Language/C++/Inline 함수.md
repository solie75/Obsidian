## c++ 에서의 함수 호출 과정

1. **함수가 호출**되면 우선 함수로 전달할 **매개변수**와 호출이 끝난 뒤 돌아갈 **반환 주소값**을 스택에 **저장**한다.
2. 프로그램의 제어가 함수의 위치로 넘어와 함수 내에 선언된 지역 변수도 스택에 저장한다.
3. 해당 함수의 모든 코드를 실행하고 실행이 종료되면 반환값을 준다.
4. 프로그램 제어는 스택에 저장된 반환 주소값으로 이동하여, 스택에 저장된 함수 호출 정보를 제거한다.

##  인라인 함수(inline function)

함수의 호출에 걸리는 시간도 부담이 되는 경우 인라인 함수를 사용한다.

인라인 함수는 **호출될 때 일반적인 함수의 호출 과정을 거치지 않고, 함수의 모든 코드를 호출된 자리에 바로 삽입**하는 방식의 함수이다. 
인라인 함수는 시간은 절약할 수 있지만 함수 호출 과정에서 생기는 여러 이점을 포기하게 된다. 따라서 매우 적은 함수만을 인라인 함수로 선언하는 것이 좋다.

## 인라인 함수 선언

```c++
inline 함수의 원형
또는
inline 함수의 정의
```

예제)
```c++
inline int Sub(int x, int y) { return x - y; }
inline void Print(int x) { cout << "계산 결과는" << x << "이다."; }

int main(void)
{
	int num1 = 5, num2 = 3;
	int result;

	result = Sub(num1, num2);
	Print(result);

	return 0;
}
```

보통 인라인 함수는 크기가 작으므로, 함수의 원형이 나오는 자리에 함수의 본체 까지 정의하는 경우가 많다.

위의 예제는 곧 다음과 같이 인라인 코드로 삽입되어 실행된다.
```c++
int main(void)
{
	int num1 = 5, num2 = 3;
	int result;

	{
		int x = 5, int y = 4;
		result = x - y;
	}

	{
		int x = result;
		cout << "계산 결과는" << x << "이다.";
	}

	return 0;
}
```

※ 인라인 함수에서는 재귀 호출이 허용되지 않는다.

## 매크로 함수와 인라인 함수

C언어에서는 C++ 의 인라인 함수와 비슷한 기능의 매크로 함수(macro function)을 사용한다. # define 선행 처리 지시문에 함수의 정의를 전달함으로써, 함수처럼 동작하는 매크로를 만들 수 있다.

하지만 매크로 함수는 일반 함수와는 달리 단순 치환만 하기 때문에, 일반 함수와 똑같은 방식으로 동작하지 않는다.

이러한 매그코 함수를 일반 함수 처럼 사용하기 위해서는 모든 인수를 괄호로 감싸야 한다.

예제)
```c++
#define SQR(X) X*X

int main(void)
{
	int x = 5;
	int result;

	result = SQR(x+3);
}

// 실행결과 result 는 23이다.
// 매크로 함수는 단순 치환만 하기 때문에 SQR(x+3)은 5+3*5+3 -> 5+15+3 -> 23
```

```c++
#define SQR(X) ((X)*(X))

int main(void)
{
	int x = 5;
	int result;

	result = SQR(x+3);
}

// 실행결과 result 는 64이다.
```

하지만 C++ 의 인라인 함수는 단순 치환이 아닌 함수의 모든 코드를 호출된 자리에 인라인 코드로 삽입해주는 것이다.
-> 따라서 일반 함수처럼 값이나 수식을 인수로 전달할 수 있고, 매개변수 타입에 맞춘 자동 타입 변환도 지원한다.

```c++
inline int Sqr(int x) {return x*x;}

int main(void)
{
	int result;
	int x = 5;

	cout << "계산 결과는" << Sqr(x+3) << "이다."
	return 0;
}

// 실행 결과
// 계산 결과는 64입니다.
```