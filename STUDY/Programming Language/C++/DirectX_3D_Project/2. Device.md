
1. 개체 구현
Source 폴더에 CEntity class 생성
```c++
// CEntity.h

#pragma once
class CEntity
{
private:
	static UINT g_iNextID;

	wstring m_strName;
	const UINT m_iID;

public:
	void SetName(wstring _name) { m_strName = _name; }
	const wstring& GetName() { return m_strName; }
	UINT GetID() { return m_iID; }

public:
	virtual CEntity* CLone() = 0;

public:
	CEntity();
	CEntity(const CEntity& _other);
	virtual ~CEntity();
};

// CEntity.cpp

#include "pch.h"
#include "CEntity.h"

UINT CEntity::g_iNextID = 0;

CEntity::CEntity()
	: m_iID(g_iNextID++)
{}

CEntity::CEntity(const CEntity& _other)
	: m_strName(_other.m_strName)
	, m_iID(g_iNextID++)
{}

CEntity::~CEntity() {}

```

Source 폴더에 07. Resource 폴더 생성
생성된 폴더에 CRes 클래스 생성

```c++
// define.h 에 Resource Type 추가
enum class RES_TYPE
{
	END,
};


// CRes.h

#pragma once
#include "CEntity.h"

class CRes
	: public CEntity
{
private:
	const RES_TYPE m_ResType;
	UINT m_iRefCount;

	wstring m_strKey;
	wstring m_strRelativePath;

	bool m_bEngine;

private:
	void SetResKey(const wstring _key) { m_strKey = _key; }
	void SetRelativePath(const wstring& _strPath) { m_strRelativePath = _strPath; }

	void AddRefCount() { ++m_iRefCount; }
	void Release();

public:
	// 리소스는 Clone 구현하지 않음
	virtual CRes* Clone() { return nullptr;}

public:
	const wstring& GetResKey() { return m_strKey; }
	const wstring& GetRelativePath() { return m_strRelativePath; }
	RES_TYPE GetResType() { return m_ResType; }
	bool IsEnginesRes() { return m_bEngine; }

public:
	CRes(RES_TYPE _type, bool _bEngine = false);
	CRes(const CRes& _Other);
	virtual ~CRes();

	friend class Ptr;
};

// CRes.cpp
#include "pch.h"
#include "CRes.h"

void CRes::Release()
{
	--m_iRefCount;
	if (m_iRefCount == 0)
	{
		delete this;
	}
}

CRes::CRes(RES_TYPE _type, bool _bEngine)
	: m_ResType(_type)
	, m_bEngine(_bEngine)
	, m_iRefCount(0)
{}

CRes::CRes(const CRes& _Other)
	: m_ResType(_Other.m_ResType)
	, m_bEngine(_Other.m_bEngine)
	, m_strKey(_Other.m_strKey)
	, m_strRelativePath(_Other.m_strRelativePath)
	, m_iRefCount(0)
{}

CRes::~CRes(){}
```

CRes 형 객체의 관리를 위해 스마트 포인터를 구현
Source 폴더에 05.ResMgr 생성
해당 폴더에 ptr.h 추가
``` c++
// ptr.h
#pragma once

template<typename T>
class Ptr
{
private:
	T* m_Res;

public:
	T* Get() const { return m_Res; }

	void operator = (T* _Res)
	{
		if (nullptr != m_Res)
		{
			m_Res->Release();
		}
		m_Res = _Res;
		if(nullptr != m_Res)
		{
			m_Res->AddRefCount();
		}
	}

	void operator = (const Ptr<T>& _Res)
	{
		if (nullptr != m_Res)
		{
			m_Res = Release();
		}
		m_Res = _Res.m_Res;
		
		if (nullptr != m_Res)
		{
			m_Res->AddRefCount();
		}
	}

	bool operator == (T* _Other)
	{
		return m_Res = _Other;
	}

	bool operator != (T* _Other)
	{
		return m_Res != _Other;
	}

	bool operator == (T* _Other)
	{
		return m_Res == _Other.m_Res;
	}

	bool operator != (T* _Other)
	{
		return m_Res != _Other.m_Res;
	}

	Ptr()
		: m_Res(nullptr)
	{};

	Ptr(T* _Res)
		: m_Res(_Res)
	{
		if (nullptr != m_Res)
		{
			m_Res->AddRefCount();
		}
	}

	Ptr(const Ptr<T>& _Other)
		: m_Res(_Other.m_Res)
	{
		if (nullptr != m_Res)
		{
			m_Res->AddRefCount();
		}
	}

	~Ptr()
	{
		if (nullptr != m_Res)
		{
			delete m_Res;
			m_Res = nullptr;
		}
	};
};
```

2. 화면 송출 구현
화면에 RenderTarget Texture 를 출력한다..

 - Device 구현 (02.Device 폴더에 CDevice 클래스 생성)
```c++
// CDevice.h
#pragma once

#include "ptr.h"

class CDevice
	: public CSingleton<CDevice>
{
	SINGLE(CDevice)
private:
	HWND m_hWnd;

	ComPtr<ID3D11Device> m_Device; // GPU 메모리 할당
	ComPtr<ID3D11DeviceContext> m_Context; // GPU 제어, 명령 수행, 렌더링 진행

	ComPtr<IDXGISwapChain> m_SwapChain;

	D3D11_VIEWPORT m_ViewPort;

	// Texture, View
	ComPtr<ID3D11Texture2D> m_RTTex;
	ComPtr<ID3D11RenderTargetView> m_RTV;
	ComPtr<ID3D11Texture2D> m_DSTes;
	ComPtr<ID3D11DepthStencilView> m_DSV;

	// 렌더타겟 해상도
	Vec2 m_vRTResolution;

public:
	HRESULT DeviceInit(HWND _hWnd, UINT _width, UINT _height);
	void ClearTarget();
	void OMSet() { m_Context->OMSetRenderTargets(1, m_RTV.GetAddressOf(), m_DSV.Get()); }
	void Present() { m_SwapChain->Present(0, 0); }

private:
	HRESULT CreateSwapChain();
	HRESULT CreateView();

public:
	ID3D11Device* GetDevice() { return m_Device.Get(); }
	ID3D11DeviceContext* GetDeviceContext() { return m_Context.Get(); }
};

// CDevice.cpp

#include "pch.h"
#include "CDevice.h"

CDevice::CDevice()
    : m_hWnd(nullptr)
    , m_ViewPort{}
{}

CDevice::~CDevice() {}

HRESULT CDevice::DeviceInit(HWND _hWnd, UINT _width, UINT _height)
{
    m_hWnd = _hWnd;
    m_vRTResolution = Vector2(_width, _height);

    int iFlag = 0;
#ifdef _DEBUG
    iFlag = D3D11_CREATE_DEVICE_DEBUG;
#endif

    // Create Device, Context
    D3D_FEATURE_LEVEL featureLevel = D3D_FEATURE_LEVEL::D3D_FEATURE_LEVEL_11_0;

    if (FAILED(D3D11CreateDevice(nullptr, D3D_DRIVER_TYPE_HARDWARE
        , nullptr, iFlag, nullptr, 0, D3D11_SDK_VERSION
        , m_Device.GetAddressOf(), &featureLevel, m_Context.GetAddressOf())))
    {
        MessageBox(nullptr, L"Device, Context 생성 실패", L"Device 초기화 오류", MB_OK);
        return E_FAIL;
    }

    if (FAILED(CreateSwapChain()))
    {
        MessageBox(nullptr, L"SwapChain 생성 실패", L"Device 초기화 오류", MB_OK);
        return E_FAIL;
    }

    if (FAILED(CreateView()))
    {
        MessageBox(nullptr, L"view 생성 실패", L"LDevice 초기화 에러", MB_OK);
        return E_FAIL;
    }


    // ViewPort 설정
    m_ViewPort.TopLeftX = 0.f;
    m_ViewPort.TopLeftY = 0.f;

    m_ViewPort.Width = m_vRTResolution.x;
    m_ViewPort.Height = m_vRTResolution.y;

    m_ViewPort.MinDepth = 0.f;
    m_ViewPort.MaxDepth = 1.f;

    m_Context->RSSetViewports(1, &m_ViewPort);

    return S_OK;
}

void CDevice::ClearTarget()
{
    FLOAT bgColor[4] = { 0.2f, 0.2f, 0.2f, 1.0f };

    m_Context->ClearRenderTargetView(m_RTV.Get(), bgColor);
    m_Context->ClearDepthStencilView(m_DSV.Get(), D3D11_CLEAR_DEPTH | D3D11_CLEAR_STENCIL, 1.0f, 0);

    m_Context->OMSetRenderTargets(1, m_RTV.GetAddressOf(), m_DSV.Get());

    m_SwapChain->Present(0,0);
}

HRESULT CDevice::CreateSwapChain()
{
    // SwapChain 설정
    DXGI_SWAP_CHAIN_DESC SwapChainDesc = {};

    SwapChainDesc.OutputWindow = m_hWnd;    // 출력 윈도우
    SwapChainDesc.Windowed = true;          // 창모드, 전체화면 모드
    
    SwapChainDesc.BufferCount = 1;
    SwapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
    SwapChainDesc.BufferDesc.Width = (UINT)m_vRTResolution.x;
    SwapChainDesc.BufferDesc.Height = (UINT)m_vRTResolution.y;
    SwapChainDesc.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
    SwapChainDesc.BufferDesc.RefreshRate.Denominator = 1;
    SwapChainDesc.BufferDesc.RefreshRate.Numerator = 60;
    SwapChainDesc.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;
    SwapChainDesc.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER::DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;
    
    SwapChainDesc.SwapEffect = DXGI_SWAP_EFFECT::DXGI_SWAP_EFFECT_DISCARD;
    
    SwapChainDesc.SampleDesc.Count = 1;
    SwapChainDesc.SampleDesc.Quality = 0;
    SwapChainDesc.Flags = 0;

    // SwapChain 생성
    ComPtr<IDXGIDevice> pDXGIDevice;
    ComPtr<IDXGIAdapter> pAdapter;
    ComPtr<IDXGIFactory> pFactory;

    HRESULT hr = S_OK;
    hr = m_Device->QueryInterface(__uuidof(IDXGIDevice), (void**)pDXGIDevice.GetAddressOf());
    hr = pDXGIDevice->GetParent(__uuidof(IDXGIAdapter), (void**)pAdapter.GetAddressOf());
    hr = pAdapter->GetParent(__uuidof(IDXGIFactory), (void**)pFactory.GetAddressOf());
    hr = pFactory->CreateSwapChain(m_Device.Get(), &SwapChainDesc, m_SwapChain.GetAddressOf());

    return hr;
}

HRESULT CDevice::CreateView()
{
    // RenderTarget 용 텍스쳐 등록
    ComPtr<ID3D11Texture2D> tTex2D;
    m_SwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (void**)tTex2D.GetAddressOf());
    if (FAILED(m_Device->CreateRenderTargetView(tTex2D.Get(), nullptr, m_RTV.GetAddressOf())))
    {
        return E_FAIL;
    }

    // DepthStencil 용 텍스쳐 등록
    D3D11_TEXTURE2D_DESC TexDesc;
    TexDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
    TexDesc.Width = m_vRTResolution.x;
    TexDesc.Height = m_vRTResolution.y;
    TexDesc.ArraySize = 1;

    TexDesc.BindFlags = D3D11_BIND_DEPTH_STENCIL;
    TexDesc.Usage = D3D11_USAGE_DEFAULT;
    TexDesc.CPUAccessFlags = 0;
    TexDesc.SampleDesc.Count = 1;
    TexDesc.SampleDesc.Quality = 0;

    TexDesc.MiscFlags = 0;
    TexDesc.MipLevels = 1;

    if (FAILED(m_Device->CreateTexture2D(&TexDesc, nullptr, tTex2D.GetAddressOf())))
    {
        return E_FAIL;
    }

    if (FAILED(m_Device->CreateDepthStencilView(tTex2D.Get(), nullptr, m_DSV.GetAddressOf())))
    {
        return E_FAIL;
    }

    return S_OK;
}
```

- EngineInit() 에서 DeviceInit() 호출
```c++
// Manager Init

    CPathMgr::GetInst()->PathMgrInit();
    CKeyMgr::GetInst()->KeyMgrInit();
    CTimeMgr::GetInst()->TimeMgrInit();

    // Device Init
    CDevice::GetInst()->DeviceInit(m_hWnd, m_vResolution.x, m_vResolution.y);

    return S_OK;
```

- EngineRender()에서 ClearTarget() 호출
```c++
void CEngine::EngineRender()
{
    CTimeMgr::GetInst()->TimeMgrRender();
    CDevice::GetInst()->ClearTarget();
}
```