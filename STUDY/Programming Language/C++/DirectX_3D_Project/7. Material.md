Texture 를 어떤 Shader 로 출력하느냐에 따라 동일한 리소스를 다양한 방식으로 표현할 수 있다. 따라서 Texture 와 Shader 를 하나씩 묶어서 하나의 Material 로 정의하고 Material 에 대한 출력 을 진행한다.


## Material

struct.h 에 Matrial 의  속성 정보를 상수 버퍼로 전달할 구조체 정의

```c++
// struct.h

...

struct tMtrlConst
{
	int arrInt[4];
	float arrFloat[4];
	Vec2 arrV2[4];
	Vec4 arrV4[4];
	Matrix arrMat[4];
};
```

value.fx 에 Material 정보를 받은 register 정의

```c++
// value.fx

cbuffer MATERIAL : register(b1)
{
    int g_int_0;
    int g_int_1;
    int g_int_2;
    int g_int_3;   //...ㄹ)

    float g_float_0;
    float g_float_1;
    float g_float_2;
    float g_float_3;   //...ㅁ)

    float2 g_vec2_0;
    float2 g_vec2_1;
    float2 g_vec2_2;
    float2 g_vec2_3;   //...ㅂ)

    float4 g_vec4_0;
    float4 g_vec4_1;
    float4 g_vec4_2;
    float4 g_vec4_3;   //...ㅅ)

    matrix g_mat_0;
    matrix g_mat_1;
    matrix g_mat_2;
    matrix g_mat_3;   //...ㄷ)

    int g_btex_0;
    int g_btex_1;
    int g_btex_2;
    int g_btex_3;
    int g_btex_4;
    int g_btex_5;
    int g_btex_6;
    int g_btex_7;   // ...ㄴ)
}

Texture2D g_tex_0 : register(t0);
Texture2D g_tex_1 : register(t1);
Texture2D g_tex_2 : register(t2);
Texture2D g_tex_3 : register(t3);
Texture2D g_tex_4 : register(t4);
Texture2D g_tex_5 : register(t5);
Texture2D g_tex_6 : register(t6);
Texture2D g_tex_7 : register(t7);   // ...ㄱ)
```
...ㄱ) Texture Register 를 총 8개로 추가한다.
...ㄴ) 각 Texture Register 에 텍스쳐가 전달 되는지에 대한 bool 값을 저장한다.

07. Resource 폴더에 03. Material 폴더 추가 -> 해당 폴더에 CMaterial 클래스 추가

```c++
// define.h

enum class RES_TYPE
{
	...
	
	MATERIAL,   // ...ㄱ)

	END,
};

enum MATERIAL_SCALAR_PARAM  // ...ㄴ) 
{
	INT_0,
	INT_1,
	INT_2,
	INT_3,

	FLOAT_0,
	FLOAT_1,
	FLOAT_2,
	FLOAT_3,

	VEC2_0,
	VEC2_1,
	VEC2_2,
	VEC2_3,

	VEC4_0,
	VEC4_1,
	VEC4_2,
	VEC4_3,

	MAT_0,
	MAT_1,
	MAT_2,
	MAT_3,
};

enum MATERIAL_TEX_PARAM   // ...ㄷ)
{
	TEX_0,
	TEX_1,
	TEX_2,
	TEX_3,
	TEX_4,
	TEX_5,
	TEX_6,
	TEX_7,

	TEX_END,
};
```
...ㄱ) 리소스 유형으로 Material 추가
...ㄴ) Material 의 어느 속성에 값을 세팅할지 쉽게 정하기 위해 enum 을 선언한다.
...ㄷ) Material 의 Texture 배열의 어느 순서에 텍스쳐를 세팅할지 정하기 위해 eum 을 선언한다.




```c++
// CMaterial.h

#pragma once
#include "CRes.h"
#include "ptr.h"
#include "CShader.h"
#include "CTexture.h"


class CMaterial :
    public CRes
{
private:
    Ptr<CShader> m_pShader;
    tMtrlConst m_MtrlConst;
    Ptr<CTexture> m_arrTex[TEX_END];

public:
    CMaterial(bool _bEngine = false);
    ~CMaterial();

private:
    virtual HRESULT LoadRes(const wstring& _strFilePath);

public:
    virtual HRESULT SaveRes(const wstring& _strFilePath);

public:
    void SetShader(Ptr<CShader> _shader);
    Ptr<CShader> GetShader();

    void SetMtrlScalarParam(MATERIAL_SCALAR_PARAM _param, const void* _src);
    void SetMtrlTexParam(MATERIAL_TEX_PARAM _param, const Ptr<CTexture>& _Tex);

    void GetMtrlScalarParam(MATERIAL_SCALAR_PARAM _param, void* _pData);
    Ptr<CTexture> GetTexParam(MATERIAL_TEX_PARAM _param);
};


// CMaterial.cpp
#include "pch.h"
#include "CMaterial.h"
#include "CPathMgr.h"

CMaterial::CMaterial(bool _bEngine)
    : CRes(RES_TYPE::MATERIAL)
    , m_MtrlConst{}
    , m_arrTex{}
{
}

CMaterial::~CMaterial()
{
}

HRESULT CMaterial::LoadRes(const wstring& _strFilePath)
{
	return S_OK;
}

HRESULT CMaterial::SaveRes(const wstring& _strFilePath)
{
	return S_OK;
}

void CMaterial::SetShader(Ptr<CShader> _shader)
{
	m_pShader = _shader;
}

Ptr<CShader> CMaterial::GetShader()
{
    return m_pShader;
}

void CMaterial::SetMtrlScalarParam(MATERIAL_SCALAR_PARAM _param, const void* _src)
{
	switch (_param)
	{
	case INT_0:
	case INT_1:
	case INT_2:
	case INT_3:
		m_MtrlConst.arrInt[_param] = *((int*)_src);
		break;
	case FLOAT_0:
	case FLOAT_1:
	case FLOAT_2:
	case FLOAT_3:
		m_MtrlConst.arrFloat[_param - FLOAT_0] = *((float*)_src);
		break;

	case VEC2_0:
	case VEC2_1:
	case VEC2_2:
	case VEC2_3:
		m_MtrlConst.arrV2[_param - VEC2_0] = *((Vec2*)_src);
		break;

	case VEC4_0:
	case VEC4_1:
	case VEC4_2:
	case VEC4_3:
		m_MtrlConst.arrV4[_param - VEC4_0] = *((Vec4*)_src);
		break;

	case MAT_0:
	case MAT_1:
	case MAT_2:
	case MAT_3:
		m_MtrlConst.arrMat[_param - MAT_0] = *((Matrix*)_src);
		break;
	}
}

void CMaterial::SetMtrlTexParam(MATERIAL_TEX_PARAM _param, const Ptr<CTexture>& _Tex)
{
    m_arrTex[(UINT)_param] = _Tex;
}

void CMaterial::GetMtrlScalarParam(MATERIAL_SCALAR_PARAM _param, void* _pData)
{
	switch (_param)
	{
	case INT_0:
	case INT_1:
	case INT_2:
	case INT_3:
	{
		int idx = (UINT)_param - (UINT)INT_0;
		*((int*)_pData) = m_MtrlConst.arrInt[idx];
	}
	break;
	case FLOAT_0:
	case FLOAT_1:
	case FLOAT_2:
	case FLOAT_3:
	{
		int idx = (UINT)_param - (UINT)FLOAT_0;
		*((float*)_pData) = m_MtrlConst.arrFloat[idx];
	}
	break;

	case VEC2_0:
	case VEC2_1:
	case VEC2_2:
	case VEC2_3:
	{
		int idx = (UINT)_param - (UINT)VEC2_0;
		*((Vec2*)_pData) = m_MtrlConst.arrV2[idx];
	}
	break;

	case VEC4_0:
	case VEC4_1:
	case VEC4_2:
	case VEC4_3:
	{
		int idx = (UINT)_param - (UINT)VEC4_0;
		*((Vec4*)_pData) = m_MtrlConst.arrV4[idx];
	}
	break;

	case MAT_0:
	case MAT_1:
	case MAT_2:
	case MAT_3:
	{
		int idx = (UINT)_param - (UINT)MAT_0;
		*((Matrix*)_pData) = m_MtrlConst.arrMat[idx];
	}
	break;
	}
}

Ptr<CTexture> CMaterial::GetTexParam(MATERIAL_TEX_PARAM _param)
{
    return m_arrTex[(UINT)_param];
}


```


뭐 때문에 ptr 수정을 했더나> nullptr 이랑 Ptr 비교였나?
=> CMaterial::UpdateMtrlData 에서 Ptr<\CShader> 와 nullptr 을 비교하는 부분이 있음


해야할 것
: Mateiral 에 Shader 와 Texture 를 적용시키고 그대로 출력 되는지 볼

tMtrlConst 의 각 요소의 역할 은 나중에 추가할 것

왜 CRes 의 LoadRes 를 private 로 선언했을 까?

LoadRes와 SaveRes 는 나중에 추가할 것
