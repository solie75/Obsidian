- 기존의 프로젝트는 화면에 출력될 객체 들에 대해서 하나의 세팅 버전을 가질 수 있었다. 하지만 구조를 변경하여 여러 세팅 버전 (Level 을 관리 할 수 있도록 한다.)  
- 프로젝트 내에서 런타임으로 상호작용을 할 객체의 클래스 (GameObject) 를 구현한다.
-  GameObject 를 종류 별로 구분하여 관리한다. (Layer)

## CGameObject

1. 05. GameObject 폴더에 CGameObject 클래스 추가

```c++
// CGameObject.h

#pragma once
#include "CEntity.h"

class CGameObject :
    public CEntity
{
private:
    bool m_bDead;

public:
    CGameObject();
    CGameObject(const CGameObject& _other);
    ~CGameObject();
};

// CGameObject.cpp

CGameObject::CGameObject(){}
CGameObject::CGameObject(const CGameObject& _other){}
CGameObject::~CGameObject(){}
```

2. 05. GameObject 폴더에 Component 폴더 추가 -> 해당 폴더에 CComponent 클래스 추가
CGameObject 는 어떤 기능을 장착할 거치대에 불과하다. 하나의 GameObject 에 특정 기능을 담당하는 Component 를 여러개 세팅함으로써 해당 GameObject 가 정의된다.

- define.h 에 component type 추가
```c++
// define.h

enum class COMPONENT_TYPE
{
	// update
	TRNASFORM,

	// render
	MESHRENDER,

	END,
};
```

```c++
// CComponent.h
#pragma once
#include "CEntity.h"

class CGameObject;

class CComponent :
    public CEntity
{
private:
    CGameObject* m_pOwner;
    const COMPONENT_TYPE m_Type;

public:
    CComponent(COMPONENT_TYPE _type);
    CComponent(const CComponent& _other);
    virtual ~CComponent();

public:
    COMPONENT_TYPE GetComponentType();
    CGameObject* GetOwnerObj();

    void CompBegin();
    void CompTick();
    void CompFinalTick();
    CComponent* Clone() = 0; //..ㄱ)
};

// CComponent.cpp
#include "pch.h"
#include "CComponent.h"

CComponent::CComponent(COMPONENT_TYPE _type)
	: m_pOwner(nullptr)
	, m_Type(_type)
{}

CComponent::CComponent(const CComponent& _other)
	: CEntity(_other)
	, m_pOwner(nullptr)
	, m_Type(_other.m_Type)
{}

CComponent::~CComponent()
{}

COMPONENT_TYPE CComponent::GetComponentType()
{
	return m_Type;
}

CGameObject* CComponent::GetOwnerObj()
{
	return m_pOwner;
}

void CComponent::CompBegin(){}

void CComponent::CompTick(){}

void CComponent::CompFinalTick(){}
```
..ㄱ) Component 복사 생성자에서 사용되기 때문에 순수가상함수로 선언한다.

03. Component 폴더에 RenderComponent 폴더 추가 -> 해당 폴더에 CRenderComponent 클래스 생성

```c++

// CRenderComponent.h

#pragma once
#include "CComponent.h"

#include "CMesh.h"
#include "CMaterial.h"

class CRenderComponent :
    public CComponent
{
private:
    Ptr<CMesh> m_pMesh;
    Ptr<CMaterial> m_pMaterial;

public:
    CRenderComponent(COMPONENT_TYPE _type);
    ~CRenderComponent();

public:
    virtual void CompRender() = 0;

public:
    void SetMesh(Ptr<CMesh> _mesh);
    void SetMaterial(Ptr<CMaterial> _mtrl);

    Ptr<CMesh> GetMesh();
    Ptr<CMaterial> GetMaterial();
};

// CRenderComponent.cpp

#include "pch.h"
#include "CRenderComponent.h"

CRenderComponent::CRenderComponent(COMPONENT_TYPE _type)
    : CComponent(_type)
{
}

CRenderComponent::~CRenderComponent()
{
}

void CRenderComponent::SetMesh(Ptr<CMesh> _mesh)
{
    m_pMesh = _mesh;
}

void CRenderComponent::SetMaterial(Ptr<CMaterial> _mtrl)
{
    m_pMaterial = _mtrl;
}

Ptr<CMesh> CRenderComponent::GetMesh()
{
    return m_pMesh;
}

Ptr<CMaterial> CRenderComponent::GetMaterial()
{
    return m_pMaterial;
}
```

CGameObject 소멸자에서 컴포넌트 삭제할 때  array 를 삭제 하게 되는데 프로젝트에 array, vector, map 에 비슷한 상황이 많으므로 템플릿화 하여 적용한다.

00.Header 폴더에 func.h 추가

```c++
// func.h
#pragma once

template<typename T, UINT Size>
void Safe_Del_Array(T* (&arr)[Size])
{
	for (UINT i = 0; i < Size; ++i)
	{
		if (nullptr != arr[i])
		{
			delete arr[i];
		}

	}
}

template<typename T, UINT Size>
void Safe_Del_Vec(vector<T*>& _vec)
{
	for (size_t i = 0; i < _vec.size(); ++i)
	{
		if (nullptr != _vec[i])
		{
			delete _vec[i];
		}
	}
	_vec.clear();
}

template<typename T1, typename T2>
void Safe_Del_Map(map<T1, T2>& _map)
{
	for (const auto& pair : _map)
	{
		if (nullptr != pair.second)
		{
			delete pair.second;
		}
	}

	_map.clear();
}
```

global.h 에 func.h 를 include

```c++
// global.h

...
#include "func.h"
```

```c++
// CDevice.cpp
CDevice::~CDevice()
{
    Safe_Del_Array(m_arrConstBuffer);
}
```