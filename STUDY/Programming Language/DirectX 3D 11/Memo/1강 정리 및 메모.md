# 정리

windows 데스크톱 애플리케이션 으로  새 프로젝트 생성

main.cpp 에서 
HWND g_hWnd 전역변수 선언하여 CreateWindow 의 반환값을 담는다.
MyRegisterClass 의 lpzsMenuName 을 nullptr 로 바꿔 메뉴바를 없애고 lpzaClassName을 하드 코딩한다.
CreateWindow 함수의 lpClassName과 lpWindowName 또한 하드 코딩으로 바꿔준다.

게임 엔진 파트와 게임 콘텐츠 파트는 분리되어야 하기에 엔진프로젝트를 추가한다.
이때 엔진 프로그램은 정적 라이브러리와 동적 라이브러리 중에 정적 라이브러리를 사용한다.

동적 라이브러리와 정적 라이브러리의 차이는 무엇일까?

현재의 Client 프로젝트의 출력 디렉토리를 outputfile 폴더로 지정한다.

1. 정적 라이브러이의 함수를 Client 에서 사용하는 방법
- External 폴더를 만들고 그 안에 Include 폴더와 Library 폴더를 만든다.
- 각 폴더 안에  StaticLib 폴더를 만든다.
- 정적 라이브러리를 생성(StaticLib Library)하고 - 속성 - 모든구성 - 일반 - 출력 디렉터리에위의 Library\StaticLIb\을 저장한다. 또한 Debug 에서는 대상 이름뒤에 를 붙인다.
- 정적 라이브러리 를 debug , release 로 각각 빌드 하면 Library\StaticLib 폴더에 
다음과 같은 파일들이 생성된다.
- 정적 라이브러리에 클라이언트 프로젝트(이하 main.cpp) 에서 사용할 함수를 작성한다.
여기에서는 두 정수를 더하는 Add 함수를 선언한다.
- 클라이언트 프로젝트의 -속성 -링커 -추가 라이브러리 디렉터리에 External\Library 추가
- math.h 를 복사하여 External\Include\StaticLib 폴더에 붙여넣기 한다.
- main.cpp 에서 #include <StaticLib\math.h> 와 #pragma Comment(LIb, "StaticLib//StaticLib_d.lib") 를 추가한다.
- main.cpp 의 wWinMain 함수안에서 정적 라이브러리에 있는 함수가 제대로 작동되는지 확인한다.

2. 동적 라이브러리의 함수를 client 에서 사용하는 방법
- 동적 라이브러리는 빌드하면 .lib , .dll 두다 나와야 한다. 
(lib 는 암시적 링크를 할 때, dll 은 명시적 링크를 할때 사용된다.) 
(진짜 구현된 코드는 dll 에 있기에 명시적 링크를 하던 암시적 링크를 하던 dll 은 존재해야 한다.)
(이때 lib 는 실제 코드를 담고 있는 것이 아니라 dll에 어떤 함수가 존재하는지에 대한 부수적인 정보만 존재한다.)
(dll 은 실행 파일과 같은 경로에 존재해야 한다.)

- (함수의 export 처리)동적 라이브러리는 특성상 링크를 걸어 사용해야 하기 때문에 가지고 있는 함수중에 어떤것은 쓰고 어떤것은 사용하지 않는다. 따라서 함수별로 export 할 것인지에 대해 설정 값을 넣어주어야 한다.-> 공개처리 마킹되어있는 함수만 사용가능하다.
-> export 하지 않으면 .lib 파일은 나오지 않는다.
(함수의 export 처리를 위하여 헤더에 붙이는 )
- extern "C" - 관용적으로 쓰이며, 작성한 함수가 c++ 뿐만 아니라 C 에서도 사용이 가능하다는 뜻 
- __declspec(dllexport)
-> 동적 라이브러리 빌드 시 .lib 파일 생성

 
- 암시적 링킹
프로젝트가 시작될대 무조건 링크를 걸고 프로젝트가 종료되면 링크를 덩달아 끊어버림 -> 암시적 링킹 
해당 파일을 include 하고 동적 라이브러리 lib 파일을 pragma comment 하는 것

ifdef 으로 dllexport 와 dllimport 적용
client 에서 빌드 될때에는 import 를 DynamicLib에서 빌드 될 때에는 Export 를 적용
그냥 dll 헤더 파일에서 볼때에는 dllexport 로 되어 있지만 
client 의 main.cpp 에서 #include 된 dll 헤더 파일을 '문서로 이동'을 통해 가면 dllimport 로 되어 있음을 확인 할 수 있다.

참조하는 동적 라이브러리 헤더 파일은 수정될 때마다 inlcude 폴더의 파일과 dll 파일을 최신으로 덮어쓰기 해주어야 한다.

- 명시적 링킹
(lib 파일 없이 dll 로만 작동)
(LoadLibrary() 함수에 dll 파일 경로를 인자로 줘서  dll의 핸들을 반환받는다.)
(그 핸들에서 함수포인터를 뽑아 쓰고)
(FreeLibrary(dll 핸들) 함수로 연결을 끊는다.)

-> LoadLibrary에 dll 파일 경로를 인자로 주고 그에 대한 dll의 핸들값을 받는다.
-> GetProcAddress(dll 핸들값, 함수명) 
/ 헤더 include 로 해당 cpp 에서 이미 함수를 알고 있는 암시적 링킹과는 다르게 명시적 링킹으로 GetProcAddress() 를 통해 함수를 찾아야한다.
/ 함수 포인터를 리턴한다.
-> 찾아오는 함수를 받기 위해서 전방에 typedef 로 함수의 형태를 정의한다.
-> 정의한 함수 자료형에 GetProcAddress 의 반환값을 그에 맞게 캐스팅하여 대입한다.
-> FreeLibrary 에서 연결에 끊기기 전까지 해당 함수 사용
-> FreeLibrary(dll 핸들값) 함수로 연결을 끊는다. 



외부 종속성 폴더란? (강사 화면에서는 안보이는데 나에게는 있음)

storage class 란?
기억 영역 분류 auto, register, static, extern
각 클라스는 상호 베타적이라 두가지 이상의 키워드를 함께 사용할 수 없다.
- auto :  지역변수를 선언할 때 아무것도 지정하지 않은 경우 기본값으로 지정되는 storage class
- register : 변수가 메모리 대신 레지스터에 저장되면 좋겠다는 '희망사항'을 컴파일러에게 알려주는 storage class
(레지스터에 저장된 변수는 메모리에 저장된 변수보다 훨씬 더 빠르게 접근가능 -> 성능 향상을 꾀할 수는 있다.)
(레지스터에 저장되려변 변수의 크기가 레지스터 사이즈보다 같거나 작아야 한다 -> 1 word)
(레지스터는 메모리처럼 주소값을 갖을 수 없기에 변수의 주소값을 구하는 &연산자는 사용할 수 없다.)
- static : 지역변수의 생병주기를 다르게 하여 함수를 빠져나가더라도 값을 유지할 수 있게 한다. (static 활용 참조)
- extern : 프로그램을 구성하는 파일들이 여러 개일 때 다른 파일에서 정의된 전역 변수나 함수를 접근할 수 있게 참고를 제공
(exterun 으로 선언된 전역변수는 초기화 할 수 없다.)
[참조 : https://gracefulprograming.tistory.com/54#--%--static ]



2 정적 라이브러리 Engine 생성
- 출력 디렉터리 설정
- 디버그 실행파일 명 + _d
- 미리 컴파일된 헤더 설정( 프로젝트 설정에서는 만들기로 / pch.h, pch.cpp 설정에서는 사용으로 지정)
- 디버그 와 릴리즈 시 client 측에서 Engine.dll 과 Engine_d.dll 을 구분하기 위해 디버그 기본 전처리 문구인 _DEBUG 를 기준으로 main.cpp 에서 ifdef 으로 분기처리한다.







**
꺽쇠 안에 있는 라이브러리의 경우, 컴파일러가 알고 있는 경로에서 헤덮일을 찾아서 포함합니다.
"" 안에 들어있는 라이브러리의 경우, 소스코드의 같은 사용자가 정의한 디렉토리 안에서 헤더 파일을 찾아서 포함합니다.
#pragma comment 는 obj 파일에 커멘트를 남기라는 명렁어 입니다. 이 명령어는 linker 가 그 obj 파일을 처리할 때 읽힙니다.
#pragma commnet(lib, "") 과 같은 경우에는 해당 라이브러리를 library dependencies list 에 추가하라는 뜻입니다. 
 이는 프로젝트 속성 창 -> Linker -> Input -> Additional Dependencies 에서 추가하는 것과 같은 기능을 합니다.

Q #pragma comment(lib, "~.lib") 와 헤더 디렉터리 설정(clinet 속성 -> 링커 -> 일반 -> 추가 라이브러리 디렉터리 설정) 으로 헤더를 추가해 주는것 을 둘다 해야 하는 이유는? 둘다 라이브러리 파일을 main.cpp 에서 사용하겠다는 의미 아닌가?
- 우선 vs 설정(추가 라이브러리 디렉터리 설정) 상에서 조절하는 것은  [해당 경로에 있는 모든 라이브러리 파일을 사용하겠다] 가 아니라 [이 위치에서 라이브러리 파일들을 찾아보겠다] 에 가깝습니다.
- 그리고 #pragma commnet(lib, "~lib")는 해당 파일(~.lib)을 사용하겠다는 의미 입니다.
- 정리하자면 vs 설정 상에서 범위를 지정하면  #pragma commnet 는 그 범위안에서 지정한 파일을 사용하겠다는 의미입니다. 
- ++ 더하자면 #pragma commnet와 똑같은 역할로 vs 설정 에서 링커 -> 입력 -> 추가 종속성 에서 수동으로 사용하겠다는 파일을 추가할 수 도 있습니다.

** 위와 같은 헤더 파일의 추가는 일일히 수동으로 해주어야 한다 이것을 자동으로 되게끔 구조를 잡자
1. .bat 파일 생성
2. 복사 하지 않을 헤더 리스트를 담은 .txt 파일 생성
3. 해당 프로젝트 속성 -> 빌드이벤트 -> 빌드 전 이벤트 -> 명령줄 -> 편집 -> cd 로 배치파일이 위치한 경로 설정 줄바꿈 call 배치파일
--> 해당 프로젝트를 빌드하면 이제 전처리기 이전에 빌드 전 이벤트가 발생하여 exclude_list.txt 에 적혀있는 헤더들을 제외한 모든 헤드파일들을 bat 파일에 적힌 명령어를 수행한다.

배치파일 명령어 설명
xcopy : 하위 디렉터리를 포함하여 파일 및 디렉터리를 복사한다. 
구문 xcopy <Source> [<Destination>] [/exclude:fileName]
<Source> : 복사 하려는 파일의 이름과 위치를 지정
[<Destination>] : 복사하려는 파일의 대상을 지정
/s : 비어 있지 않은 경우 디렉터리 및 하위 디렉터리에서 복사한다.
/y : 기존 대상 파일을 덥어쓸 것인지를 확인하는 메시지를 표시하지 않는다.
/exclude:FileName 각 파일의 별도줄의 문자열에 대하여 복사할 파일의 절대 경로 부분과 일치하는 경우 해당 파일을 복사되지 않는다.
*.h : 파일명에 상관없이 헤더를 지칭

# 메모

새프로젝트 - Windows 데스크톱 애플리케이션

파일 기본 세팅

게임 엔지 ㄴ= 범용성이 중요

게임 엔진 파트와 게임 콘텐츠 파트가 분리 되어야 한다.

게임 엔진 : 게임을 만드는데 반복적으로 있어야 하는 기능들 

엔진 프로젝트 새로 추가

그럼 엔진 프로젝트와 클라이언트 프로젝트를 어떻게 연결하는가

엔진 프로젝트 만들 때에는 정적 라이브러리를 사용한다.

동적 연결 라이브러리와 정적 라이브러리의 차인는?

동적 연결 라이브러리 도 추가


세개의 프로젝트 중에 하나가 두꺼운 글씨인데 그것은 셋중에 두꺼운 글씨가 시작 프로젝트로 설정 되어 있는 것이다 -> 나머지 두개는 실행용 프로젝트가 아니다.

라이브러리는 실행파일이 사용할 수 있는 함수 집합체로 생각한다. ( 라이브러리는 실행파일이 아니다)

설정
출력 경로

설정에서 Outfile bin bin_d

External (가져다 쓰는 라이브러리 모을 폴더)

다른 라이브러리를 가져다 쓸때에는 헤더 파일이 존재해야 하고 그 헤더 파일에는 내가 사용할 기능의 이름들이 있다

라이브러리폴더에 정적 라이브러리 lib 폴더를 만든다

라이브러리를 만들때 디버그와 릴리스 모드로 두가지 만들어 줘야 한다. 그래야 클라이언트의 디버그 릴리스에 각각 맞게 이어지기 때문이다.
-> 디버그 버전 대상이름 뒤에 _d 추가

정적 라이브러리네 새로운 기능 추가

라이브러리 경로
<>로 찾을 수 있었던 이유 이미 프로젝트 구성 성분에 경오가 저장되어 있는 것
"" 는 상대 경로 (참조하는 cpp 와 같은 폴더에 존재한다 는 뜻)

포함 디렉터리

커스텀으로 만든 라ㄹ이브러리 파일들은 헤더파일을 가져온거 플러스 lib 파일도 찾아서 연결해 주어햐야 한다.

헤더도 알고 그 헤더가 가리키는 진짜 라이브러리 내용도 #pragma comment 로 가져와야 한다.

svn 으로 프로젝트 받기

assert43
한국축구

svn

최종빌드가 와뇰된 시점에서는 정적 라이브러리의 코드가 실행파일에 포함되어 존재한다.

dll 이 메모리에 올라가고 그것을 사용하는 프로그램들이 링크한다.
최초로 그 dll 을 사용하는 프로그램이 메모리상에 dll 을 올린다.

dll ㅣ 많은 프로그램들이 공유해서 사용하는 경우 사용한다.

강사 프로젝트에는 외부 종속성이 없는데 나는 있는데 무엇때문인가?

동적은 lib dll 둥다 나와야 한다.

암시적 링킹 ( 무조건 갖다 쓰는 경우 ) (dll 의 특징이 없음) lib
명시적 링킹 dll
어떤 방식을 하더라도 dll 파일은 무조건 존재해야 한다. 
