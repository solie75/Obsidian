
## Create ' Device, Context, SwapChain, RenderTargetView ' in CEngine::EngineInit()

1. Engine-> Source 에 02.Device 추가
	1. 02.Device 에 Device.h 와 Device.cpp 추가
	2. 이때 Device 객체로 사용될 변수를 [[개념 | COM]] 을 사용하여 다음의 객체들을 [[Smart pointer | 스마트 포인터]] 로 선언. (다음 참조 [[Device & Context | Device]] [[CreateSwapChain( ) | SwapChain]] [[ID3D11Texture2D | Texture2D]] )
```c++
	// 다이렉트 관련 dll 에서 생성까지 되기 때문에 사용자는 클래스를 자세히 알수가 업다.
	// 따라서 클래스 타입을 맴버로 두는 것이 아니라 그 주소를 맴버 변수로 둬서 활용한다.
	ComPtr<ID3D11Device> m_Device; 
	
	// gpu 메모리 할당 , 메모리 공간을 제어한다. 
	// gpu 에 명령함 , gpu 제어, 랜더링, 동작 수행
	ComPtr <ID3D11DeviceContext> m_Context; 

	ComPtr <IDXGISwapChain> m_SwapChain; // 

	// gpu 메모리 사용(텍스쳐가 gpu 에 만들어 지고 그 주소를 지칭하며 이 주소을 통해서 관리된다. ) renderTarget Texture
	ComPtr <ID3D11Texture2D> m_RTTex; 
	ComPtr <ID3D11RenderTargetView> m_RTV;

	// DepthStencilTexture
	ComPtr <ID3D11Texture2D> m_DSTex; 
	ComPtr <ID3D11DepthStencilView> m_DSV;

	D3D11_VIEWPORT m_ViewPort;

```

2. DeviceInit( ) : Device 초기화
	1. [[D3D11CreateDevice( )]] 로 Device와 Context 생성
	2. SwapChain 생성
		1. CDevice::CreateSwapChain( ) 호출
		2. [[DXGI_SWAP_CHAIN_DESC]] 구조체 설정
		3. COM 객체로 스왑체인 생성 (IDXGIDevice, IDXGIAdapter, IDXGIFactory)
		4. D3D11CreateDevice( )에서 생성된 디바이스형 객체(m_Device) 에 대해 [[QueryInterface( )]]호출하여 IDXGIDevice형 객체(DXGI)에 포인터를 할당.
		5. IDXGIDevice 형 객체에 대해 [[STUDY/Programming Language/DirectX 3D 11/Function/GetParent( ) | GetParent()]]를 호출해, IDXGIAdapter 형 객체(adapter)에 포인터를 할당.
		6. IDXGIAdapter형 객체에 대해 [[STUDY/Programming Language/DirectX 3D 11/Function/GetParent( ) | GetParent()]]를 호출해, IDXGIFactory 형 객체에 포인터를 할당.
		7. IDXGIFactory형 객체에 대해 IDXGIFactory::[[CreateSwapChain( )]] 을 호출하여  IDXGISwapChain 형 <span style="color: yellow">객체에 스왑체인을 저장한다.</span>
	3. View 생성
		1. CDevice::CreateView( ) 호출
			1. Rendertarget View 생성
				1. 스왑체인 객체(예, m_SwapChain)에 대해 [[GetBuffer( )]]를 호출한다. 이를 통해서 RenderTargetTexture 용으로 쓰기 위해 미리 선언해둔 객체(예, m_RTTex)에 Texture2D 를 생성하여 대입한다.
				2. 디바이스 객체 에 대해 [[CreateRenderTargetView( )]] 를 호출하여 rendertarget 용 <span style="color: yellow">객체에 view 를 생성</span>하여 대입한다.
			2. Depthstencil View 생성
				1. D3D11_TEXTURE2D_DESC 구조체 변수 생성 및 DepthStencil  용도에 맞게 내용 대입
				2. [[CreateTexture2D( )]] 로 <span style="color: yellow">Depth Stencil 용 텍스쳐를 생성</span>한다.
				3. [[CreateDepthStencilview( )]]로 <span style="color: yellow">Depth Stencil 용 view 를 생성한다.</span>
	4. 출력 타겟 설정
		1. [[OMSetRenderTargets( )]]  : 해당 메서드로 [[8. Output - Merger Stage | Output Merger Stage]] 에 <span style="color:yellow ">렌더타겟을 바인딩한다.</span>
	5. viewport 설정
		1. [[Viewport]] 설정
		2. [[RSSetViewports( )]] 메서드로 뷰포트 배열을 파이프 라인의 rasterizer stage에 바인딩한다.

3. 매니저 추가 및 
	1. [[11. PathMgr | PathMgr]]
	2. [[03. KeyMgr, TimeMgr 생성 | TimeMgr]]
	3. [[03. KeyMgr, TimeMgr 생성#1. KeyMgr | KeyMgr]]

4. 정점 버퍼 그리기 테스트(이하 Test)의 초기화
	1. Engine 라이브러리에 Test.h 와 Text.cpp 생성
	2. 00.Header 폴더에 struct.h 생성 후 global.h 에 # include -> struct.h 에 <span style="color: yellow">Vertex 구조체 (예, tVertex)를 추가.</span>-> typedef tVertex Vtx; 로 정점 구조체 명 재정의
	3. TestInit( )
		2. 4개의 Vtx를 가지는 배열(arrVtx)을 생성하고 인데스 0부터 2까지 설정한다.(각각의 <span style="color: yellow">점의 위치와 색 값을 설정</span>한다.)
		3. 버퍼 Desc 구조체([[D3D11_BUFFER_DESC]]) 생성 및 설정.
		4. 버퍼  [[Subresources]] 설정 : [[D3D11_SUBRESOURCE_DATA]] 구조체 변수 선언 D3D11_SUBRESOURCE_DATA::pSysMem에 arrVtx 대입.
		5. [[CreateBuffer( )]]호출로 <span style="color: yellow">버퍼 생성</span> 
		6. shader file 생성 및 경로 가져오기 구현
			-  해당 shader  file 에서는
			1. (float3형 위치, float4형 색 정보를 가진)입력 구조체(VS_IN), (float4형 위치 정보를 가진)출력 구조체(VS_OUT)를 생성한다
			2. vertex shader 프로그램(VS_Test) 와 pixel shader 프로그램(PS_Test)을 생성한다 .(<span style="color: green">프로그램이라고 말하는게 맞는걸까</span>) 이 때 pixel shader 프로그램은  vertex shader 프로그램의  출력 값을 입력값으로 받는다.
		7. Vertex shader 코드와 Pixel shader 코드를 대상으로 각각  [[D3DCompileFromFile( )]]을 호출하여 컴파일된 코드에 접근할 수 있는 ID3DBlob 인터페이스에 대한 이중 포인터를 각각 생성한다.
		8. CreateVertexShader(), CreatePixelShader() 함수를 호출하여 VertexShader, PixelShader 생성.
		9. <span style="color: orange">어떻게 input-assembler stage 에 input-buffer data 를 스트리밍을 할 것인지를 정의하는데 사용되는</span> **input layout object**를 생성한다.
			1. 위치와 색에 대한 정보를 전달하기 위해서 [[D3D11_INPUT_ELEMENT_DESC]] 구조체를 두개 선언하여 위치와 색에 대한 설명을 각각 대입한다.
