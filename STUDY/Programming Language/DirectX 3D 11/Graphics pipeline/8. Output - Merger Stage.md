output merger stage 는 pipeline state, pixel shader 로 generate 된 pixel data, render target 의 내용(content), depth/stencil buffer 의 내용(content) 의 결합을 사용하여 최종적으로 렌더링된 pixel 의 색상을 generate 한다. output merge stage는 pixel 이 어떻게 시각화 될 것인지를 결정하고 최종적 pixel 색상을 블랜딩 하는 최종 단계이다.

Differences between Direct3D 9 and Direct3D 10:

-   Direct3D 9 implements alpha testing (using [alpha-testing state](https://learn.microsoft.com/en-us/windows/desktop/direct3d9/alpha-testing-state)) to control whether a pixel is written to an output render target.
-   Direct3D 10 and higher does not implement an alpha test (or alpha testing state). This can be controlled using a pixel shader or with depth/stencil functionality.

### Depth-Stencil Testing Overview

^a8ed13

texture resource 로 create 된 depth stencil buffer 는 depth data 와 stencil data 를 포함할 수 있다. depth data 는 카메라와 가장 가까운 픽셀을 결정하는데 사용된다. stencil data는 업데이트 될 수 있는 pixel 을 masking 하는데 사용된다. 궁극적으로 depth 와 stencil 값 데이터는 output merger stage 에서 pixel 이 그려져야하는지 아닌지의 여부를 결정하는데 사용된다. 다음의 다이어그램은 개념적으로 어떻게 depth-stencil 테스트가 수행되는지를 보여준다.

![[Pasted image 20230126234428.png]]

depth stencil object 는 depth stencil state 를 요약 압축(캡슐화) 한다. 응용 프로그램은 depth stencil state 를 특정할 수 있고 또는 output merger stage 에서 기본 값을 사용한다. Blending operation 은 multisampling 이 비활성화 인 경우 각 pixel 당 수행된다. 만약 multisampling 이 활성화 된 경우, blending 은 각 multisample별로 발생한다. 

그려져야 하는 픽셀을 결정하기 위한 depth buffer 를 사용하는 과정을 depth buffering 또는 z-buffring 이라 부른다.

depth value 가 output merger stage 에 도달한 때에 그것들은 언제나 고정된다. z = min(viewport.MaxDepth, max(Viewport.MinDepth,z)) 부동 소수점 규칙(floating-point rules) 을 사용하는 depth buffer 의 format/ precision 에 따라서.
clamping 후에, depth value 는 기존의 depth buffer value 와 비교된다 (DepthFunc 를 사용하여). 바운딩된 depth buffer 가 없는 경우 depth test 는 언제나 통과한다.

depth buffer format 에 stencil component 가 없거나 depth buffer 바운딩이 없는 경우 stencil test 는 언제나 통과한다. otherwise, functionality is unchanged from Direct3D 9.

하나의 시간에는 오직 하나의 depth/stencil buffer 가 활성화가 가능하다. 바인딩된 모든 reource view 는 depth/stencil view 와 일치해야 한다( 동일한 사이즈와 동일한 차원). 이것은 resource size 가 반드시 일치해야 한다는 의미가 아니라 view 크기가 일치해야 한다는 의미이다.

### Blending Overview

blending은 최종의 pixel color 를 create 하기 위해서 하나 이상의 pixel value 를 결합한다. 다음의 다이어그램은 pixel data 를 blending 하는 것을 포함한 과정을 보여준다.
![[Pasted image 20230127010926.png]]

개념적으로, output merger stage 에서 두번 시행되는 이 flow chart(순서도)를 시각화 할 수 있다. 첫 번재로 RGB data 를 blending 한다. 반면에 병렬적으로 두 번째는 alpha data 를 blending 한다. blend state를 create 하고 설정하기 위한 API 를 어떻게 사용하는 지를 보기 위해서는 [[8. Output - Merger Stage#^7fee47]]을 참조한다.

Fixed-function blend 는 각 render target 에 대하여 독립적으로 활성화 될 수 있다. 그러나 거기에는 오직 하나의 blend controls의 설정만이 있다. 고로, blending 이 활성화된 모든 rendertarget에 동일한 blending이 적용된다. blending 전에 blend value( BlendFactor 포함) 는 언제나 render target format 의 범위(range)에 고정(clamping)된다.  clamping(고정) 은 render target type 에 따라 각 render target 별로 수행된다. 유일한 예외는 clamping 되지 않은 float 16, float11, float10 format들 이므로 이러한 format에서 blend operation들은 출력 형식으로서 적어도 동등한 precision/range 로 수행될 수 있다. NaN과 부호있는 zero (signed zero)는 모든 경우(case)에 전파된다. (0.0 혼합 가중치 포함(blending weight : ([[Geometry Blending#^1f63fa]])참조)) "여기서부터 01 27"





.유일한 예외는 고정되지 않은 float16, float11 또는 float10 형식이므로 이러한 형식에 대한 블렌드 작업이 출력 형식과 최소한 동일한 정밀도/범위로 수행될 수 있습니다. NaN과 부호 있는 0은 모든 경우에 전파됩니다(0.0 혼합 가중치 포함).

sRGB 렌더링 대상을 사용하는 경우 런타임은 혼합을 수행하기 전에 렌더링 대상 색상을 선형 공간으로 변환합니다. 런타임은 값을 렌더링 대상에 다시 저장하기 전에 최종 혼합 값을 다시 sRGB 공간으로 변환합니다.


## Configuring Depth-Stencil Functionality

^7fee47