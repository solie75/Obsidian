변환 단계

1. 월드 변환
2. 카메라 변환
	1. 시야각, 종횡비, view volumn(시야각, 종횡비 등에 의해 결정되는 시야의 가시영역) near plane과 far plane 응로 이루어진 frustum, 
	2. frustom 의 바깥은 출력되지 않는다. 또한 frustom 의 경계에 오브젝트가 걸처져있다면 경계를 기점으로 안쪽의 부분은 출력하고 외부의 부분은 버려지는데 이를 clipping 이라 한다. 이는 clip stage 에서 시행된다.
3. 투영 변환
	2. 투영변환은 카메라 공간의 모든 오브젝트를 원근법을 적용하여 scale 을 변형시킨 뒤 Clip spcae 로 전달한다.
	3. 투영변환이 3d 를 2d 로 변환시키는 것이 아니라 원근법이 적용되었을 뿐 다른 3d 물체로 변형되는 것이다.

Tesselation stage (hull + Tesselation + domain)

- 주어진 모델의 정점의 개수를 조정한다. (정점을 늘려 더 세부적으로 표현하거나 정점을 줄여 더 대략적으로 표현할 수 있다. 이를 LOD(level of detail)이라 한다.) Tesselation을 사용하면 하나의 모델에 여러 해상도의 모델 데이터를 가지고 있을 필요가 없다. (tesselation을 사용하지 않고 카메라로부터 먼 객체를 적은 연산으로 표현하기 위해서는 디자이너 단계에서 한 오브젝트당 폴리곤 수에 따른 여러 단계의 모델을 만들어서 사용하기 때문.)

Geometry stage

- 기본 도혀에서 정점을 추가하거나 삭제하여 모델을 변결할 수 있는 세위더. Getmetry shader 로 정점 정보를 조금 추가하여 표현할 수 있는 모델이라면 그만큼의 정점정보를 빼고 저장할 수 있으니 메모리 적으로 이득을 취할 수 있다. 
- 예를 들어  gpu 로 전달된 정점 데이터 정보를 가지고 gpu 내에서 해당 정점 정보를 복사하여 여러 복사된 오브젝트를 만들어 낼 수 있다. 

Rasterizer 

3D Mesh 를 2D로 투영했을 때 해당 2D 이미지를 모니터로 출력하기 위해서는 각 픽셀이 어느 색상 정보를 가져야 하는지 알아야 한다. 이때 픽셀로 이루어진 모니터를 작은 사각형들로 이루어진 큰사각형이라고 비교할때 각 작은 사각형에 어떤 색상이 가장 많이 차지하느느지에 따라  각 작은 사각형(픽셀)의 색상이 정해진다. 
1. 출력하고자 하는 메쉬가 포함된 영역의 모든 픽셀이 각각 픽셀 쉐이더를 호출한다.
2. 삼각형의 세 정점에 할당되었던 여러 데이터 (pox uv,  등) 등의 데이터는 보간 되어 삼각형 내부의 각각 픽셀 쉐이더로 넘어돈다. 

rasterizer는 고정 파이프 라인 단계로 프로그래밍이 불가능하고 하드 웨어 자체 알고리즘 을 통해 동작한다
1. clipping
	1. 
2. 원근 나눗셈
3. 뒷면 제거
4. 뷰포트 전환
5. 스캔 변환

보간? 픽셀에서 보간하는냐 정점에서 보간하는냐의 차이는?

pixel shader

output merger

