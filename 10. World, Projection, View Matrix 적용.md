
### CB_TYPE::TRANSFORM 형 const buffer 생성

1. CDevice::CreateConstBuffer 에서 m_arrConstBuffer[CB_TYPE::TANSFORM] 에 대해 CreateConstBuffer 를 호출할 때 첫번째 매개변수인 버퍼의 크기에 대해서 구현할 Transform 을 구조체로 선언하고 그 구조체의 크기를 인자로 전달한다.
2. struct.h 에서 tTransform 구조체 선언
```c++
struct tTransform
{
	Matrix matWorld;
	Matrix matView;
	Matrix matProjection;
};
```
3. 1번의 CreateConstBuffer 의 첫번째 매객변수로 sizeof(tTransform) 전달.
4. test.fx 에서
	1. cbuffer 형 TRANSFORM 가 기존에 float4 형으로 플레이어 객체의 위치값을 가지고 있었던것을 tTransform 구조체에 맞게 아래의 구문과 같이 수정
	2. VS_TEST 에서 입력된 정점 좌표에 상수 버퍼 값을 더하는 부분을 다음으로 대체한다.
		1. output.vPosition = mul(float4(_in.vPos, 1.f), g_matWorld);
		2. 이때 in.vPos 와 1.f 를 따로 자료형을 지정해줄 필요없이 간편하게 곱하기 위해서 mul() 함수를 사용한다. -> 이를 통해서 기존의 객체의 local space 상 좌표에 변환을 적용하여 반환한다.
```c++
cbuffer TRANSFORM : register(b0)
{
    row_major matrix  g_matWorld;
    row_major matrix  g_matView;
    row_major matrix  g_matProj;
};
```
-> 컴퓨터는 다차원 배열로 행렬을 구성할 때, 행렬을 어떤 순서로 접근할 것인지에 대한 순서가 존재한다.
![[Pasted image 20230419193232.png]]
위와 같이 행렬을 접근하는 순서가 다르기 때문에, 사용하는 라이브러리에 명시된 순서를 확인하고 그에 맞게 연산을 해주어햐 한다.
DirectX 에서는 행렬 순서가 row-major(행우선) 이고 HLSL 에서는 column-major(열우선) 이다.
행렬이 DirectX 에서 쉐이더 상수로 넘어갈 때 자동적으로 row-major 에서 column-major 로 변환된다. 때문에 쉐이더 코드에서도 DirectX 와 같은 순서로 연산하기 위해서는 상수버퍼의 행렬을 전치 행렬로 변환하여 갱신하거나 쉐이더에서 행렬을 선언할 때 row-major 로 선언한다.
# World Matrix

- world matrix 란

객체를 생성할 때 객체는 독자적인 원점을 가지고 그에 따라 정점의 위치가 결정된다. 이때 객체가 존재하는 공간을 local space 라고 한다. 그러한 객체들 여럿은 하나의 scene 에 존재 시키기위해서 scene 을 기준으로 원점을 잡고 각 개체들을 scene 의 특정 좌표에 위치시킨다. 이때 scene 의 공간을 world space 라 하고 각 객체를 scene 즉, world space 에 위치시키기 위해서 객체의 원점을 world space 의 특정 world coodination 으로 변화하는 것을 world transform 이라 한다. 그리고 world transform 을 위해 객체의 원점에 적용되는 연산의 주체가 world matrix 이다. 

### world matrix 생성 및 업데이트

1. global.h 에 typedef XMMATRIX Matrix 선언 (XMMATRIX 는 4X4 행렬이다.)
2. CTransform.h 의 맴버 변수로 Matrix m_matWorld 선언
3. CTransform::ComponentFinaltick() 에서
	1. Matrix 형 변수 (matScale) 를 선언하고 [[Function#^63eb56|XMMatrixIdentity()]] 를 호출하여 그 반환값을 matScale 에 대입한다. 
	2. [[Function#^754474|XMMatrixScaling()]] 함수를 호출하고 m_vRelativeScale의 x, y, z 를 매개변수로 전달한다. -> 이는 전달된 값을 바탕으로 크기 변환 행렬을 생성한다. -><span style="color: green">작성된 코드에서는 matScale 은 생성해놓고 XMMatrixScaling()함수의 결과인 크기 변환 행렬을 matScale에 대입하지 않고 있다. 왜?</span>
	3. Matrix 형 변수 (matRot) 를 선언하고 XMMatrixIdentity() 를 호출하여 그 반환값을 matRot 에 대입한다.
	4. matRot 에 XMMatrixRotationX(m_vRelativeRot.x)의 값을 대입한다
	5. matRot 에 XMMatrixRotationY (m_vRelativeRot.y)의 값을 $*=$ 으로 대입한다.
	6. matRot 에 XMMatrixRotationZ(m_vRelativeRot.z)의 값을 $*=$ 으로 대입한다.
		1. matRot 에x, y, z 기준 회전 배열이 모두 연산되어 대입되었음을 뜻한다.
	7. Matrix 형 변수(matTranslation) 을 선언하고 XMMatrixTramslation(m_vRelativeRot.x, m_vRelativeRot.y, m_vRelativeRot.z) 를 호출하여 그 반환값을 matTranslation 에 대입한다.
	8. m_matWorld 에 matScale * matRot * matTranslation 을 대입한다.

4. CTransform::UPdateTransformData()에서
	1. SetConstBufferData 의 첫번째 매개변수인 m_vRelative 를 world transform 인 m_matWorld로 대체하고 두 번째 매개변수인 sizeof() 의 인자로 Matrix 를 전달한다

### 원형 Mesh 생성하고 키 입력으로 깊이(z)값 바꾸기

##### CResourceMgr::CreateDefaultMesh() 에서

1. 기존의 사각형 mesh 인 TestMesh 의 정점을 설정하는 부분에서, Vtx 형 변수(v) 에 대해 v.vPosition 에 대입되는 Vec3 형의 마지막 인자는 위치의 z 값을 뜻한다. TestMesh 의 네 정점의 z 값 설정을 0.f 로 수정한다.
2. 기존의 Addresource 의 첫번째 매개면수로 L"TextMesh" 를 L"LectMesh"로 수정 -> CLevelMgr::LevelMgrInit() 에서 오브젝트 생성 부분, Ptr<CMesh.> 형 변수를 다음으로 수정 -> Ptr<CMesh.> pMesh = CResourceMgr::GetInst()->FindRes<CMesh.>(L"RectMesh")
4. vecVtx.clear(), vecIdx.clear() 호출

-  CircleMesh 생성
1. 반지름으로 쓰일 float 형 변수 (fRadius) 선언 후  0.5f 대입
2. 원도 결국 원의 중심점을 꼭짓점으로 두며 원의 반지름을 이등변으로 하는 삼각형의 집합으로 이루어저야 한다. -> 원을 구성하는 삼각형의 수로 쓰일 UINT 형 변수 (Slice) 선언 후 40 대입
3. 원을 이루는 이등변 삼각형에서 이등변이 이루는 각을 나타내는 float 형 변수 (fTheta) 에 XM_2PI / (float)Slice 대입 -> 이 때 XM_2PI 는 $2\pi$ 로 6.283185307f 로 정의되어있다.
4. 원의 중심점을 다음과 같이 설정한다.
```c++
	v.vPosition = Vec3(0.f, 0.f, 0.f);
	v.vColor = Vec4(1.f, 1.f, 1.f, .1f);
	v.vUV = Vec2(0.5f, 0.5f);
	vecVtx.push_back(v);
```
-> 여기에서 local space 기준, UV coordination 기준 모두 원의 중심이 좌표계 중심에 있음을 알 수 있다.
5.  정점 위치 지정
	1. 원의 둘레 위에 존재하게 되는 정점의 위치를 정한다. 이는 Slice 값에 따라 40개 존재한다.
```
	for (UINT i = 0; i < Slice; ++i)
	{
		v.vPosition = Vec3(fRadius * cosf(fTheta * (float)i), fRadius * sinf(fTheta * (float)i), 0.f);
		v.vUV = Vec2(v.vPosition.x + 0.5f, -v.vPosition.y + 0.5f);
		vecVtx.push_back(v);
	}
```
6. 반지름과 cosf 으로 좌표의 x 값을, 반지름과 sinf 으로 좌표의 y 값을 구한다.
7. UV 값의 경우 UV 좌표계의 중심이 (0.f, 0.f) 이 아닌 (0.5f, 0.5f) 임에 따라 vPosition 의 값에 0.5f 를 더해주고 있다. 이때 v.vPosition.y 가 음수로 취급하는 이유는 local 좌표계와 UV 좌표계가 Y축 방향이 반대이기 때문이다. 실제로 v.vPosition.y 를 음수로 안하는 경우 local 에 정점이 생기는 순서는 반시계방향인것에 반해 UV 에 정점이 생기는 순서는 시계방향인 것을 알 수 있다. 
8. 인덱스 설정
```c++
for (UINT i = 0; i < Slice-1; ++i)
	{
		vecIdx.push_back(0);
		vecIdx.push_back(i + 2);
		vecIdx.push_back(i + 1);
	}
```
-> 최소한의 인덱싱으로 모든 삼각형을 그려야 한다. 
-> 이 방식으로는 0번, 1번, 마지막(Slice 값) 정점 으로 이루어진 마지막 삼각형이 vecIdx 에 기록되지 않기 때문에 따로 설정해준다.
```c++
	vecIdx.push_back(0);
	vecIdx.push_back(1);
	vecIdx.push_back(Slice);
```

9. Mesh 생성
	1. pMesh 에 new CMesh 를 대입하여 새로운 CMesh 형 변수 값을 저장한다.
	2. pMesh 에 대해 CreateMesh 를 호출하고 그 매개변수로 vecVtx 와 vecIdx 에 대한 size() 와 data() 를 전달한다.
	3. AddResource(L"CircleMesh", pMesh) 를 호출하여 원형 메쉬를 저장한다.
	4. vecVtx 와 vecIdx 를 .clear() 호출한다.

10. Mesh 출력
	- CPalyerScript::ComponentTick()에서
```
	if (KEY_TAB(KEY::A))
	{
		Vec3 vRot = GetOwner()->GetTransform()->GetRelativeRot();
		vRot.z += DT * XM_PI;
		GetOwner()->GetTransform()->SetRelativeRot(vRot);
	}
```
- CLevelMgr::LevelMgrInit() 에서
	- Ptr<CMesh.> testMesh = CResourceMgr::GetInst()->FindRes<CMesh.>(L"RectMesh") 의 RectMesh 를 CircleMesh 로 변경 -> 두개의 객체가 모두 원형으로 출력된다.
	- 두번째 인덱스 레이어에 오브젝트를 추가하는 부분에서 testMesh = CResourceMgr::GetInst()->FindRes<CMesh.>(L"RectMesh") 코드를 추가한다면 출력되는 두개의 오브젝트중 하나는 사각형으로 하나는 원형으로 출력된다.

# Camera 적용

- struct.h 의 tTransform 을 extern 처리한다.
	- extern tTransform g_transform;

- 06.Component 폴더에 3. Camera 폴더 추가 및 해당 폴더에 CCamera class 생성
	- 매개변수로 종횡비, view matrix, projection matrix 를 갖는다.
	- 맴버 함수로 view matrix, 와 projection matrix 에 대한 Get~Matrix 함수( 이때 반환값은 const Matrix& 이다.)와 CComponent 의 순수가상함수(ComponentFinalTick(), CLONE())을 override 한 함수를 받는다.
	- 생성자의 초기화 리스트에서
		- 부모 클라스인 CComponent 생성자를 호출하고 COMPONENT_TYPE::CAMERA 를 전달한다.
		- m_fAspectRatio 를 1.f 로 초기화 한다.
	- 생성자의 body 에서
		- 랜더타겟의 해상도를 가지고 와서 종횡비를 계산한다.
			- CDevice 에 Vec2 GetRenderResolution(){ return m_vRenderResolution; } 추가
			- 