
### CB_TYPE::TRANSFORM 형 const buffer 생성

1. CDevice::CreateConstBuffer 에서 m_arrConstBuffer[CB_TYPE::TANSFORM] 에 대해 CreateConstBuffer 를 호출할 때 첫번째 매개변수인 버퍼의 크기에 대해서 구현할 Transform 을 구조체로 선언하고 그 구조체의 크기를 인자로 전달한다.
2. struct.h 에서 tTransform 구조체 선언
```c++
struct tTransform
{
	Matrix matWorld;
	Matrix matView;
	Matrix matProjection;
};
```
3. 1번의 CreateConstBuffer 의 첫번째 매객변수로 sizeof(tTransform) 전달.
4. test.fx 에서
	1. cbuffer 형 TRANSFORM 가 기존에 float4 형으로 플레이어 객체의 위치값을 가지고 있었던것을 tTransform 구조체에 맞게 아래의 구문과 같이 수정
	2. VS_TEST 에서 입력된 정점 좌표에 상수 버퍼 값을 더하는 부분을 다음으로 대체한다.
		1. output.vPosition = mul(float4(_in.vPos, 1.f), g_matWorld);
		2. 이때 in.vPos 와 1.f 를 따로 자료형을 지정해줄 필요없이 간편하게 곱하기 위해서 mul() 함수를 사용한다. -> 이를 통해서 기존의 객체의 local space 상 좌표에 변환을 적용하여 반환한다.
```c++
cbuffer TRANSFORM : register(b0)
{
    row_major matrix  g_matWorld;
    row_major matrix  g_matView;
    row_major matrix  g_matProj;
};
```
-> 컴퓨터는 다차원 배열로 행렬을 구성할 때, 행렬을 어떤 순서로 접근할 것인지에 대한 순서가 존재한다.
![[Pasted image 20230419193232.png]]
위와 같이 행렬을 접근하는 순서가 다르기 때문에, 사용하는 라이브러리에 명시된 순서를 확인하고 그에 맞게 연산을 해주어햐 한다.
DirectX 에서는 행렬 순서가 row-major(행우선) 이고 HLSL 에서는 column-major(열우선) 이다.
행렬이 DirectX 에서 쉐이더 상수로 넘어갈 때 자동적으로 row-major 에서 column-major 로 변환된다. 때문에 쉐이더 코드에서도 DirectX 와 같은 순서로 연산하기 위해서는 상수버퍼의 행렬을 전치 행렬로 변환하여 갱신하거나 쉐이더에서 행렬을 선언할 때 row-major 로 선언한다.
# World Matrix

- world matrix 란

객체를 생성할 때 객체는 독자적인 원점을 가지고 그에 따라 정점의 위치가 결정된다. 이때 객체가 존재하는 공간을 local space 라고 한다. 그러한 객체들 여럿은 하나의 scene 에 존재 시키기위해서 scene 을 기준으로 원점을 잡고 각 개체들을 scene 의 특정 좌표에 위치시킨다. 이때 scene 의 공간을 world space 라 하고 각 객체를 scene 즉, world space 에 위치시키기 위해서 객체의 원점을 world space 의 특정 world coodination 으로 변화하는 것을 world transform 이라 한다. 그리고 world transform 을 위해 객체의 원점에 적용되는 연산의 주체가 world matrix 이다. 

### world matrix 생성 및 업데이트

1. global.h 에 typedef XMMATRIX Matrix 선언 (XMMATRIX 는 4X4 행렬이다.)
2. CTransform.h 의 맴버 변수로 Matrix m_matWorld 선언
3. CTransform::ComponentFinaltick() 에서
	1. Matrix 형 변수 (matScale) 를 선언하고 [[Function#^63eb56|XMMatrixIdentity()]] 를 호출하여 그 반환값을 matScale 에 대입한다. 
	2. [[Function#^754474|XMMatrixScaling()]] 함수를 호출하고 m_vRelativeScale의 x, y, z 를 매개변수로 전달한다. -> 이는 전달된 값을 바탕으로 크기 변환 행렬을 생성한다. -><span style="color: green">작성된 코드에서는 matScale 은 생성해놓고 XMMatrixScaling()함수의 결과인 크기 변환 행렬을 matScale에 대입하지 않고 있다. 왜?</span>
	3. Matrix 형 변수 (matRot) 를 선언하고 XMMatrixIdentity() 를 호출하여 그 반환값을 matRot 에 대입한다.
	4. matRot 에 XMMatrixRotationX(m_vRelativeRot.x)의 값을 대입한다
	5. matRot 에 XMMatrixRotationY (m_vRelativeRot.y)의 값을 $*=$ 으로 대입한다.
	6. matRot 에 XMMatrixRotationZ(m_vRelativeRot.z)의 값을 $*=$ 으로 대입한다.
		1. matRot 에x, y, z 기준 회전 배열이 모두 연산되어 대입되었음을 뜻한다.
	7. Matrix 형 변수(matTranslation) 을 선언하고 XMMatrixTramslation(m_vRelativeRot.x, m_vRelativeRot.y, m_vRelativeRot.z) 를 호출하여 그 반환값을 matTranslation 에 대입한다.
	8. m_matWorld 에 matScale * matRot * matTranslation 을 대입한다.

4. CTransform::UPdateTransformData()에서
	1. SetConstBufferData 의 첫번째 매개변수인 m_vRelative 를 world transform 인 m_matWorld로 대체하고 두 번째 매개변수인 sizeof() 의 인자로 Matrix 를 전달한다

### 원형 Mesh 생성하고 키 입력으로 깊이(z)값 바꾸기

- CResourceMgr::CreateDefaultMesh() 에서

1. 기존의 사각형 mesh 인 TestMesh 의 정점을 설정하는 부분에서, Vtx 형 변수(v) 에 대해 v.vPosition 에 대입되는 Vec3 형의 마지막 인자는 위치의 z 값을 뜻한다. TestMesh 의 네 정점의 z 값 설정을 0.f 로 수정한다.
2. 기존의 Addresource 의 첫번째 매개면수로 L"TextMesh" 를 L"LectMesh"로 수정 -> CLevelMgr::LevelMgrInit() 에서 오브젝트 생성 부분, Ptr<CMesh.> 형 변수를 다음으로 수정 -> Ptr<CMesh.> pMesh = CResourceMgr::GetInst()->FindRes<CMesh.>(L"RectMesh")
4. 