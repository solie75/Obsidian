해야할 것들
1. 몸체가 머리를 따라가는 로직이 본 게임과 다르다. 수정할 것
2. hp 구현하기
3. 캐릭터의 공격 패턴 상하좌우 구현하기


-----
나아가야할 방향.

현재 projectile이 가지고 있는 위치 자체가 방향 벡터이다.
위치를  normalize 한다.
한 틱에 움직일 거리를 d라고 할때 
normalize(위치) * d 를 Update 에서 해주면 된다.

방향ㅇ을 정할때 현재의 위치를 하면 원점에서 멀어지는 모양새가 된다.

따라서 처음에 생성될 때 발사원로부터의 발사체의 방향을 구해 저장해야 한다.

----------

발사체 까지 완성되었다. 어떻게 여러개의 발사체를 발사 할수 있을까

현재 높이가 같아서 비교 에러가 뜬다.. equreless 를 도입해야 하나.

아니면 GameObject 를 다 검색해서 fireball 이 있으면 i 에 특정 값을 곱해줘야 하나. 근데 그것도 두번 뿐이다.

값이 같을 때를 도입해보자.

-> DSType 에 LessEquare 을 도입하고, CCamera::ZSortTransparencyGameObjects 의 std::sort 에서 비교 함수를 아예 빼버려  동일 z 값도 허용 되도록 하였다.
------

현재 fireball 이 cutout 이 안된다는 문제가 있음

---

현재 fireball 이 엉뚱하게 head 에서 나가고 있음 

circle : 세 방향으로 불을 연속적으로 쏜다.
rhombus : 50 방향으로 불을 쏜다.
squre : 부하들을 쏜다.
triangle : 용암을 쏜다.

-----

projectile 의 개수에 따라 속도가 달라진다.

프레임도 확확 떨어져

이미 50 개 나온다고 속도가 다른 것부터 문제ㅈ

1. AddGameObject 로 mGameObjects vector 에 추가한다.
2.

모든 객체를 camera 에서 RenderingMode 별로 분류하여 render 하기 위해서는 GameObject 에 저장해야 하는것 아닌가?

---

프레임이 떨어질때 속도가 느려지는 것은 프레임별로 계산을 하기 때문이다. -> 프레임이 아니라 절대 시간을 기준으로 계산해야 한다. -> diff 를 절대 시간으로 계산한다. 
=> 해결
------
rhombus의 fireball 의 각도가 맞지 않음
=> 해결

----
충돌체 빨간색으로 변경
---
보스 및 보스 충돌체 사이즈 변경
=> 변경 완료
 각 몸체 사이의 거리 변경
=> 완료
보스 idle 및 light 추가
---
rhombus 이미지 수정 128x128
=> 완료
---
보스 패턴 fms 설계하기
---
debug 투명
dubug 끼리 z 깊이 값에 따라 디버그 출력을 막는다.
->어차피 끄면 안보이기 때문에 나중으로 미룬다.

debug 순서
1. CApp::Init()
 -  CRenderMgr::Init() 에서 debugShader 와 DedugMaterial 생성
 -  CEditor::GetInst()->Initialize() -> mDebugObjects의 Rect 요소 에 MeshRender (debugShader 와 DedugMaterial )추가
2. CApp::Release()
 - mDebugObjects 의 모든 요소 delete
-- 

OnCollision() 에서 DebugColor 를 hlsl 로 보내 색을 변경한다.
=> 완료

----

한번 hlsl 로 debug color 를 보내면 모든 debug mesh 가 한번에 색상이 변경된다. OnCollision 이 호출된 debugMesh 만 색상이 변경되어야 한다.

CEditor::init() 에서 mesh 와 material 을 mDebugObject[Rect] 의 MeshRender 에 저장한다.
CEditor::Render() 에서 DebugMesh 로 각 Debug mesh 의 정보를 가져와 Rendering 한다.

-> Debug mesh 에 색상을 추가하여 Rendering 에서 mesh 의 색상 자체를 바꿔 버린다.

-> Debug.hlsl 에서는 입력받은 색상을 출력하기만 하면 된다.


-> 기존의 OnCollision 등의 함수에서 Debug.hlsl 로 보내는 cb 코드 삭제
-> 위의 DebugMesh 를 통한 색상 변환이 된다면 DebugColor CB 관련 코드 삭제


한 프레임에서 CollisionMgr 가 먼저인가 Collider2D::LateUPdatee 가 먼저인가.
update 와 lateupdate 사이에 CollisionMgr 가 있어야한다.

-> cCollider2D 에 맴버변수 bool 값 추가

-> 해당 bool 값에 따라 CEditor::DebugRender() 에서 다른 색상을 DebugColor 로 Debug.hlsl 에 바인딩 한다.

---

충돌은 bool 값으로 정하는 것이 아니라 충돌 개수로 정한다.
-> 각각의 충돌체는 충돌 횟수를 가지고 있는다 0이면 충돌 상태가 아니고 1 이상이면 충돌 상태이다.
///
Collider 값은 무조건 debug Mesh 의 크기로 이루어 져야 한다.

--- 

배경 추가

=> 완료

배경 충돌체 추가
-> 배경 자체에 충돌체를 만들면  배경 내부 모두가 충돌 범위가 된다.
-> 배경의 사방으로 충돌체를 총 네개 만들어준다.
-> 발사체를 발사했을 때 엉뚱하게 충돌이 적용된다.

하나의 객체에 4개의 충돌체를 추가
DebugMesh 의 출력은 제대로 이루어 졌다.
Collision 의 경우 Up 충돌체 만이 작용하며 또한 위치가 0.0 고정이다. 하지만 그 크기는 Debugmesh 와 같았다.
-> 즉 Collider 의 크기는 적용되는데 위치가 적용되지 않았다.
-> ObjectCollision 에서  게임 오브젝트끼리 비교하며 각자의 충돌체 하나를 가져와서 ColliderCollision 을 하기 때문에 하나의 객체가 여러개의 충돌페를 갖는것은 충돌 계산을 하기에 부적절하다.

-> 이미지가 없는 게임 객체를 만들어 
=> 완료

-> 아직 debug 위치와 적용 위치가 다르다.
-> 일단 객체니까 AddObject 에서의 객체 위치 설정을 바꿔준다.
=> 완료
-> 이미지가 없어야할 객체에 배경 이미지가 들어가 있다 ;;
=> 배경 충돌체 완료

---
배경과 투사체, 투사체와 플레이어의 충돌 추가
=> 완료

---
배경과 투사체 투사체와 플레이어의 충돌시 투사체 삭제 로직 구현
-> 충돌된 투사체가 늘어 날 수록 뚫고 지나가는 투사체들이 보임
삭제하는 것도 마찬가지이다.
-> 투사체 객체가 Dead 상태가 되는 것과 CollisionMgr 가 충돌을 계산하는 과정에서 나온 오류이다.  -> Dead 상태 변경의 시기와 CollisionMgr 에 LateUpdate 를 추가하여 해결

---

LateUpdate 에서도 Update 를 똑같이 하고 ObjectColision 에서 Minus ColliderNum() 를 구현하지 말고 ObjectCollision 에서 갖는 
=> 해결
=> 이러면 맨 마지막 layer 끼리만 MunusColliderNum 이 호출된다.

함수를 따로 만들것

=> 완료

Projectile 터지는 애니메이션 과 그에 대한 Dead 처리 수정
IsCollider == True 일 때 PlayerAnimation(Explosion fire ball);
=> 완료
fire ball 애니메이션 종료 때에 ObjectState  = Dead;
=> 완료

분석하기 
1. 머리의 움직임 패턴
2. 몸체의 공격 패턴
3. 

Head 의 움직임 구현 (영상으로 헤드가 움직이는 로직 분석하기)
1. 일단은 네모로 도는 것을 구현하자
2. Head 의 State 정하기

Head State(1. Idle, 2. Attack, 3. Paused, 4. Dead)
body State(1. Idle, 2. MoveAttack, 3. long dist Attack, 4 Paused, 5. Dead)

언제 머리를 회전할 것인가. 맵을 9등분...?
머리의 앞에 충돌체를 세개 두고 방향을 정한다. 

머리의 앞과 좌우 양 옆에 충돌체를 두고 정면의 충돌체가 배경 충돌체와 충돌하면 반의 확률로 좌우 선
-> 일단은 벽에 부딫쳤을 때 각도를 계산해서 그것에 맞춰 튕겨나오는 것으로 하자

1. 머리가 바라보고 있는 방향 그에 대한 텍스쳐 출력 및 텍스쳐 회전
1. 머리가 방향을 가지고 있어야 한다.( 머리의 중심 (머리의 위치)) 에서 머리의 앞부분으로 향하는 방향벡터

방향 벡터는 지금까지 어딘가에서 어디를 빼서 정하지 않았나?
그럼 back 왼족의 좌표에서 중앙의 좌표를 빼고 normalize 하면 되는 것 아닌가?
객체에서의 방향 벡터나 맵 중심에서계산한 방향베터나 같다. 

---

Head 의 4 방향을 이미지를 가지고 Angle 에 따른 Head 이미지의 전환을 구현한다.

